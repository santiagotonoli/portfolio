{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\";\nimport { useControllableState, useId, useSafeLayoutEffect } from \"@chakra-ui/hooks\";\nimport { callAllHandlers, createContext, getValidChildren, isUndefined, mergeRefs, normalizeEventKey } from \"@chakra-ui/utils\";\nimport * as React from \"react\";\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\n\nexport function useTabs(props) {\n  var {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    orientation = \"horizontal\"\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"defaultIndex\", \"onChange\", \"index\", \"isManual\", \"isLazy\", \"orientation\"]);\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n\n\n  var [focusedIndex, setFocusedIndex] = React.useState(defaultIndex != null ? defaultIndex : 0);\n  var [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange\n  });\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n\n  React.useEffect(() => {\n    if (!isUndefined(index)) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   *\n   * This manager is used to store only the tab nodes that are not disabled, and focusable.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\" and \"Tab 3\", since `Tab 2` is disabled\n   */\n\n  var enabledDomContext = useDescendants();\n  /**\n   * This manager is used to store all tab nodes whether disabled or not.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\", \"Tab 2\" \"Tab 3\".\n   *\n   * We need this for correct indexing of tabs in event a tab is disabled\n   */\n\n  var domContext = useDescendants();\n  /**\n   * generate a unique id or use user-provided id for\n   * the tabs widget\n   */\n\n  var id = useId(props.id, \"tabs\");\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    orientation,\n    enabledDomContext,\n    domContext,\n    htmlProps\n  };\n}\nvar [TabsProvider, useTabsContext] = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n});\nexport { TabsProvider, useTabsContext };\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\n\nexport function useTabList(props) {\n  var {\n    setFocusedIndex,\n    focusedIndex,\n    orientation,\n    enabledDomContext\n  } = useTabsContext();\n  var count = enabledDomContext.descendants.length;\n  /**\n   * Function to update the selected tab index\n   */\n\n  var setIndex = React.useCallback(index => {\n    var tab = enabledDomContext.descendants[index];\n\n    if (tab != null && tab.element) {\n      tab.element.focus();\n      setFocusedIndex(index);\n    }\n  }, [enabledDomContext.descendants, setFocusedIndex]);\n  var onKeyDown = React.useCallback(event => {\n    var nextTab = () => setIndex((focusedIndex + 1) % count);\n\n    var prevTab = () => setIndex((focusedIndex - 1 + count) % count);\n\n    var firstTab = () => setIndex(0);\n\n    var lastTab = () => setIndex(count - 1);\n\n    var isHorizontal = orientation === \"horizontal\";\n    var isVertical = orientation === \"vertical\";\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => isHorizontal && nextTab(),\n      ArrowLeft: () => isHorizontal && prevTab(),\n      ArrowDown: () => isVertical && nextTab(),\n      ArrowUp: () => isVertical && prevTab(),\n      Home: firstTab,\n      End: lastTab\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [count, focusedIndex, orientation, setIndex]);\n  return _extends({}, props, {\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  });\n}\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\n\nexport function useTab(props) {\n  var {\n    isDisabled,\n    isFocusable\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isDisabled\", \"isFocusable\"]);\n\n  var {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    enabledDomContext,\n    domContext,\n    selectedIndex\n  } = useTabsContext();\n  var ref = React.useRef(null);\n  /**\n   * Think of `useDescendant` as the function that registers tab node\n   * to the `enabledDomContext`, and returns its index.\n   *\n   * Tab is registered if it is enabled or focusable\n   */\n\n  var enabledIndex = useDescendant({\n    disabled: Boolean(isDisabled),\n    focusable: Boolean(isFocusable),\n    context: enabledDomContext,\n    element: ref.current\n  });\n  /**\n   * Registers all tabs (whether disabled or not)\n   */\n\n  var index = useDescendant({\n    context: domContext,\n    element: ref.current\n  });\n  var isSelected = index === selectedIndex;\n\n  var onClick = () => {\n    setFocusedIndex(enabledIndex);\n    setSelectedIndex(index);\n  };\n\n  var onFocus = () => {\n    var isDisabledButFocusable = isDisabled && isFocusable;\n    var shouldSelect = !isManual && !isDisabledButFocusable;\n\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n\n  var clickableProps = useClickable(_extends({}, htmlProps, {\n    ref: mergeRefs(ref, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  }));\n  var type = \"button\";\n  return _extends({}, clickableProps, {\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus)\n  });\n}\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\n\nexport function useTabPanels(props) {\n  var context = useTabsContext();\n  var {\n    id,\n    selectedIndex\n  } = context;\n  var validChildren = getValidChildren(props.children);\n  var children = validChildren.map((child, index) => /*#__PURE__*/React.cloneElement(child, {\n    isSelected: index === selectedIndex,\n    id: makeTabPanelId(id, index),\n\n    /**\n     * Refers to the associated tab element, and also provides an accessible name to the tab panel.\n     */\n    \"aria-labelledby\": makeTabId(id, index)\n  }));\n  return _extends({}, props, {\n    children\n  });\n}\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\n\nexport function useTabPanel(props) {\n  var {\n    isSelected,\n    id,\n    children\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isSelected\", \"id\", \"children\"]);\n\n  var {\n    isLazy\n  } = useTabsContext();\n  return _extends({\n    /**\n     * Puts the tabpanel in the page `Tab` sequence.\n     */\n    tabIndex: 0\n  }, htmlProps, {\n    children: !isLazy || isSelected ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id\n  });\n}\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\n\nexport function useTabIndicator() {\n  var context = useTabsContext();\n  var {\n    selectedIndex,\n    orientation,\n    domContext\n  } = context;\n  var isHorizontal = orientation === \"horizontal\";\n  var isVertical = orientation === \"vertical\"; // Get the clientRect of the selected tab\n\n  var [rect, setRect] = React.useState(() => {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return undefined;\n  });\n  var [hasMeasured, setHasMeasured] = React.useState(false); // Update the selected tab rect when the selectedIndex changes\n\n  useSafeLayoutEffect(() => {\n    var _tab$element;\n\n    if (isUndefined(selectedIndex)) return undefined;\n    var tab = domContext.descendants[selectedIndex];\n    var tabRect = tab == null ? void 0 : (_tab$element = tab.element) == null ? void 0 : _tab$element.getBoundingClientRect(); // Horizontal Tab: Calculate width and left distance\n\n    if (isHorizontal && tabRect) {\n      var {\n        left,\n        width\n      } = tabRect;\n      setRect({\n        left,\n        width\n      });\n    } // Vertical Tab: Calculate height and top distance\n\n\n    if (isVertical && tabRect) {\n      var {\n        top,\n        height\n      } = tabRect;\n      setRect({\n        top,\n        height\n      });\n    } // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n\n\n    var id = requestAnimationFrame(() => {\n      setHasMeasured(true);\n    });\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, domContext.descendants]);\n  return _extends({\n    position: \"absolute\",\n    transition: hasMeasured ? \"all 200ms cubic-bezier(0, 0, 0.2, 1)\" : \"none\"\n  }, rect);\n}\n\nfunction makeTabId(id, index) {\n  return id + \"--tab-\" + index;\n}\n\nfunction makeTabPanelId(id, index) {\n  return id + \"--tabpanel-\" + index;\n}","map":{"version":3,"mappings":"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","names":["useClickable","useDescendant","useDescendants","useControllableState","useId","useSafeLayoutEffect","callAllHandlers","createContext","getValidChildren","isUndefined","mergeRefs","normalizeEventKey","React","useTabs","props","defaultIndex","onChange","index","isManual","isLazy","orientation","htmlProps","focusedIndex","setFocusedIndex","useState","selectedIndex","setSelectedIndex","defaultValue","value","useEffect","enabledDomContext","domContext","id","TabsProvider","useTabsContext","name","errorMessage","useTabList","count","descendants","length","setIndex","useCallback","tab","element","focus","onKeyDown","event","nextTab","prevTab","firstTab","lastTab","isHorizontal","isVertical","eventKey","keyMap","ArrowRight","ArrowLeft","ArrowDown","ArrowUp","Home","End","action","preventDefault","role","useTab","isDisabled","isFocusable","ref","useRef","enabledIndex","disabled","Boolean","focusable","context","current","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","type","makeTabId","tabIndex","makeTabPanelId","undefined","useTabPanels","validChildren","children","map","child","cloneElement","useTabPanel","hidden","useTabIndicator","rect","setRect","left","width","top","height","hasMeasured","setHasMeasured","tabRect","_tab$element","getBoundingClientRect","requestAnimationFrame","cancelAnimationFrame","position","transition"],"sources":["../../src/use-tabs.ts"],"sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useId,\n  useSafeLayoutEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  callAllHandlers,\n  createContext,\n  Dict,\n  EventKeyMap,\n  getValidChildren,\n  isUndefined,\n  mergeRefs,\n  normalizeEventKey,\n} from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance ðŸš€:\n   * If `true`, the TabPanel rendering will be deferred\n   * until it is open.\n   */\n  isLazy?: boolean\n}\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    orientation = \"horizontal\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = React.useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  React.useEffect(() => {\n    if (!isUndefined(index)) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   *\n   * This manager is used to store only the tab nodes that are not disabled, and focusable.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\" and \"Tab 3\", since `Tab 2` is disabled\n   */\n  const enabledDomContext = useDescendants()\n\n  /**\n   * This manager is used to store all tab nodes whether disabled or not.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\", \"Tab 2\" \"Tab 3\".\n   *\n   * We need this for correct indexing of tabs in event a tab is disabled\n   */\n  const domContext = useDescendants()\n\n  /**\n   * generate a unique id or use user-provided id for\n   * the tabs widget\n   */\n  const id = useId(props.id, `tabs`)\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    orientation,\n    enabledDomContext,\n    domContext,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<ReturnType<typeof useTabs>, \"htmlProps\">\n\nconst [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport { TabsProvider, useTabsContext }\n\ntype Child = React.ReactElement<any>\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    orientation,\n    enabledDomContext,\n  } = useTabsContext()\n\n  const count = enabledDomContext.descendants.length\n\n  /**\n   * Function to update the selected tab index\n   */\n  const setIndex = React.useCallback(\n    (index: number) => {\n      const tab = enabledDomContext.descendants[index]\n      if (tab?.element) {\n        tab.element.focus()\n        setFocusedIndex(index)\n      }\n    },\n    [enabledDomContext.descendants, setFocusedIndex],\n  )\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => setIndex((focusedIndex + 1) % count)\n      const prevTab = () => setIndex((focusedIndex - 1 + count) % count)\n      const firstTab = () => setIndex(0)\n      const lastTab = () => setIndex(count - 1)\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => isHorizontal && nextTab(),\n        ArrowLeft: () => isHorizontal && prevTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [count, focusedIndex, orientation, setIndex],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  id?: string\n  isSelected?: boolean\n  panelId?: string\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   */\n  isDisabled?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled, isFocusable, ...htmlProps } = props\n\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    enabledDomContext,\n    domContext,\n    selectedIndex,\n  } = useTabsContext()\n\n  const ref = React.useRef<HTMLElement>(null)\n\n  /**\n   * Think of `useDescendant` as the function that registers tab node\n   * to the `enabledDomContext`, and returns its index.\n   *\n   * Tab is registered if it is enabled or focusable\n   */\n  const enabledIndex = useDescendant({\n    disabled: Boolean(isDisabled),\n    focusable: Boolean(isFocusable),\n    context: enabledDomContext,\n    element: ref.current,\n  })\n\n  /**\n   * Registers all tabs (whether disabled or not)\n   */\n  const index = useDescendant({\n    context: domContext,\n    element: ref.current,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setFocusedIndex(enabledIndex)\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(ref, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    React.cloneElement(child as Child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      /**\n       * Refers to the associated tab element, and also provides an accessible name to the tab panel.\n       */\n      \"aria-labelledby\": makeTabId(id, index),\n    }),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Dict) {\n  const { isSelected, id, children, ...htmlProps } = props\n  const { isLazy } = useTabsContext()\n\n  return {\n    /**\n     * Puts the tabpanel in the page `Tab` sequence.\n     */\n    tabIndex: 0,\n    ...htmlProps,\n    children: !isLazy || isSelected ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n\n  const { selectedIndex, orientation, domContext } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = React.useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = React.useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (isUndefined(selectedIndex)) return undefined\n\n    const tab = domContext.descendants[selectedIndex]\n    const tabRect = tab?.element?.getBoundingClientRect()\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal && tabRect) {\n      const { left, width } = tabRect\n      setRect({ left, width })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical && tabRect) {\n      const { top, height } = tabRect\n      setRect({ top, height })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, domContext.descendants])\n\n  return {\n    position: \"absolute\",\n    transition: hasMeasured ? \"all 200ms cubic-bezier(0, 0, 0.2, 1)\" : \"none\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module"}