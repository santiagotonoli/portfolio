{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\";\nimport { useControllableState, useFocusEffect, useIds, useUnmountEffect } from \"@chakra-ui/hooks\";\nimport { addItem, callAllHandlers, createContext, getNextIndex, getPrevIndex, isArray, isUndefined, mergeRefs, normalizeEventKey, removeItem, warn } from \"@chakra-ui/utils\";\nimport { useCallback, useRef, useState } from \"react\";\n/**\n * useAccordion hook provides all the state and focus management logic\n * for accordion items.\n */\n\nexport function useAccordion(props) {\n  var {\n    onChange,\n    defaultIndex,\n    index: indexProp,\n    allowMultiple,\n    allowToggle\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"onChange\", \"defaultIndex\", \"index\", \"allowMultiple\", \"allowToggle\"]); // validate the props and `warn` if used incorrectly\n\n\n  allowMultipleWarning(props);\n  allowMultipleAndAllowToggleWarning(props);\n  /**\n   * Think of this as the register to each accordion item.\n   * We used to manage focus between accordion item buttons.\n   *\n   * Every accordion item, registers their button refs in this context\n   */\n\n  var domContext = useDescendants();\n  /**\n   * This state is used to track the index focused accordion\n   * button when click on the button, tab on the button, or\n   * use the down/up arrow to navigate.\n   */\n\n  var [focusedIndex, setFocusedIndex] = useState(-1);\n  /**\n   * Reset focused index when accordion unmounts\n   * or descendants change\n   */\n\n  useUnmountEffect(() => {\n    setFocusedIndex(-1);\n  }, [domContext.descendants]);\n  /**\n   * Hook that manages the controlled and un-controlled state\n   * for the accordion.\n   */\n\n  var [index, setIndex] = useControllableState({\n    value: indexProp,\n    defaultValue: () => {\n      if (allowMultiple) return defaultIndex != null ? defaultIndex : [];\n      return defaultIndex != null ? defaultIndex : -1;\n    },\n    onChange\n  });\n  /**\n   * Gets the `isOpen` and `onChange` props for a child accordion item based on\n   * the child's index.\n   *\n   * @param idx {number} The index of the child accordion item\n   */\n\n  var getAccordionItemProps = idx => {\n    var isOpen = false;\n\n    if (idx !== null) {\n      isOpen = isArray(index) ? index.includes(idx) : index === idx;\n    }\n\n    var onChange = isOpen => {\n      if (idx === null) return;\n\n      if (allowMultiple && isArray(index)) {\n        var nextState = isOpen ? addItem(index, idx) : removeItem(index, idx);\n        setIndex(nextState);\n      } else if (isOpen) {\n        setIndex(idx);\n      } else if (allowToggle) {\n        setIndex(-1);\n      }\n    };\n\n    return {\n      isOpen,\n      onChange\n    };\n  };\n\n  return {\n    index,\n    setIndex,\n    htmlProps,\n    getAccordionItemProps,\n    focusedIndex,\n    setFocusedIndex,\n    domContext\n  };\n}\nvar [AccordionProvider, useAccordionContext] = createContext({\n  name: \"AccordionContext\",\n  errorMessage: \"useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`\"\n});\nexport { AccordionProvider, useAccordionContext };\n/**\n * useAccordionItem\n *\n * React hook that provides the open/close functionality\n * for an accordion item and its children\n */\n\nexport function useAccordionItem(props) {\n  var {\n    isDisabled,\n    isFocusable,\n    id\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isDisabled\", \"isFocusable\", \"id\"]);\n\n  var {\n    getAccordionItemProps,\n    domContext,\n    focusedIndex,\n    setFocusedIndex\n  } = useAccordionContext();\n  var {\n    descendants\n  } = domContext;\n  var buttonRef = useRef(null);\n  /**\n   * Generate unique ids for all accordion item components (button and panel)\n   */\n\n  var [buttonId, panelId] = useIds(id, \"accordion-button\", \"accordion-panel\");\n  focusableNotDisabledWarning(props);\n  /**\n   * Think of this as a way to register this accordion item\n   * with its parent `useAccordion`\n   */\n\n  var index = useDescendant({\n    element: buttonRef.current,\n    context: domContext,\n    disabled: isDisabled,\n    focusable: isFocusable\n  });\n  var {\n    isOpen,\n    onChange\n  } = getAccordionItemProps(index === -1 ? null : index);\n\n  var onOpen = () => {\n    onChange == null ? void 0 : onChange(true);\n  };\n\n  var onClose = () => {\n    onChange == null ? void 0 : onChange(false);\n  };\n\n  var shouldFocus = index === focusedIndex;\n  /**\n   * Autofocus the accordion button when\n   * the active index matched the accordion item's index\n   */\n\n  useFocusEffect(buttonRef, {\n    shouldFocus\n  });\n  /**\n   * Toggle the visibility of the accordion item\n   */\n\n  var onClick = useCallback(() => {\n    onChange == null ? void 0 : onChange(!isOpen);\n    setFocusedIndex(index);\n  }, [index, isOpen, onChange, setFocusedIndex]);\n  /**\n   * Manage keyboard navigation between accordion items.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowDown: () => {\n        var _nextAccordion$elemen;\n\n        var nextIndex = getNextIndex(index, descendants.length);\n        var nextAccordion = descendants[nextIndex];\n        nextAccordion == null ? void 0 : (_nextAccordion$elemen = nextAccordion.element) == null ? void 0 : _nextAccordion$elemen.focus();\n      },\n      ArrowUp: () => {\n        var _prevAccordion$elemen;\n\n        var prevIndex = getPrevIndex(index, descendants.length);\n        var prevAccordion = descendants[prevIndex];\n        prevAccordion == null ? void 0 : (_prevAccordion$elemen = prevAccordion.element) == null ? void 0 : _prevAccordion$elemen.focus();\n      },\n      Home: () => {\n        var _firstAccordion$eleme;\n\n        var firstAccordion = descendants[0];\n        firstAccordion == null ? void 0 : (_firstAccordion$eleme = firstAccordion.element) == null ? void 0 : _firstAccordion$eleme.focus();\n      },\n      End: () => {\n        var _lastAccordion$elemen;\n\n        var lastAccordion = descendants[descendants.length - 1];\n        lastAccordion == null ? void 0 : (_lastAccordion$elemen = lastAccordion.element) == null ? void 0 : _lastAccordion$elemen.focus();\n      }\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, index]);\n  /**\n   * Since each accordion item's button still remains tabbable, let's\n   * update the focusedIndex when it receives focus\n   */\n\n  var onFocus = useCallback(() => setFocusedIndex(index), [index, setFocusedIndex]);\n  var getButtonProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      type: \"button\",\n      ref: mergeRefs(buttonRef, ref),\n      id: buttonId,\n      disabled: !!isDisabled,\n      \"aria-expanded\": !!isOpen,\n      \"aria-controls\": panelId,\n      onClick: callAllHandlers(props.onClick, onClick),\n      onFocus: callAllHandlers(props.onFocus, onFocus),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n    });\n  }, [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId]);\n  var getPanelProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      role: \"region\",\n      id: panelId,\n      \"aria-labelledby\": buttonId,\n      hidden: !isOpen\n    });\n  }, [buttonId, isOpen, panelId]);\n  return {\n    isOpen,\n    isDisabled,\n    isFocusable,\n    onOpen,\n    onClose,\n    getButtonProps,\n    getPanelProps,\n    htmlProps\n  };\n}\n\nfunction allowMultipleWarning(props) {\n  var index = props.index || props.defaultIndex;\n  var condition = !isUndefined(index) && !isArray(index) && props.allowMultiple;\n  warn({\n    condition: !!condition,\n    message: \"If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: \" + typeof index + \",\"\n  });\n}\n\nfunction allowMultipleAndAllowToggleWarning(props) {\n  warn({\n    condition: !!(props.allowMultiple && props.allowToggle),\n    message: \"If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not\"\n  });\n}\n\nfunction focusableNotDisabledWarning(props) {\n  warn({\n    condition: !!(props.isFocusable && !props.isDisabled),\n    message: \"Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.\\n    \"\n  });\n}","map":{"version":3,"mappings":"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","names":["useDescendant","useDescendants","useControllableState","useFocusEffect","useIds","useUnmountEffect","addItem","callAllHandlers","createContext","getNextIndex","getPrevIndex","isArray","isUndefined","mergeRefs","normalizeEventKey","removeItem","warn","useCallback","useRef","useState","useAccordion","props","onChange","defaultIndex","index","indexProp","allowMultiple","allowToggle","htmlProps","allowMultipleWarning","allowMultipleAndAllowToggleWarning","domContext","focusedIndex","setFocusedIndex","descendants","setIndex","value","defaultValue","getAccordionItemProps","idx","isOpen","includes","nextState","AccordionProvider","useAccordionContext","name","errorMessage","useAccordionItem","isDisabled","isFocusable","id","buttonRef","buttonId","panelId","focusableNotDisabledWarning","element","current","context","disabled","focusable","onOpen","onClose","shouldFocus","onClick","onKeyDown","event","eventKey","keyMap","ArrowDown","nextIndex","length","nextAccordion","focus","ArrowUp","prevIndex","prevAccordion","Home","firstAccordion","End","lastAccordion","action","preventDefault","onFocus","getButtonProps","ref","type","getPanelProps","role","hidden","condition","message"],"sources":["../../src/use-accordion.ts"],"sourcesContent":["import { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useFocusEffect,\n  useIds,\n  useUnmountEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  addItem,\n  callAllHandlers,\n  createContext,\n  EventKeyMap,\n  getNextIndex,\n  getPrevIndex,\n  isArray,\n  isUndefined,\n  mergeRefs,\n  normalizeEventKey,\n  PropGetter,\n  removeItem,\n  warn,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useRef, useState } from \"react\"\n\nexport type ExpandedIndex = number | number[]\n\nexport interface UseAccordionProps {\n  /**\n   * If `true`, multiple accordion items can be expanded at once.\n   */\n  allowMultiple?: boolean\n  /**\n   * If `true`, any expanded accordion item can be collapsed again.\n   */\n  allowToggle?: boolean\n  /**\n   * The index(es) of the expanded accordion item\n   */\n  index?: ExpandedIndex\n  /**\n   * The initial index(es) of the expanded accordion item\n   */\n  defaultIndex?: ExpandedIndex\n  /**\n   * The callback invoked when accordion items are expanded or collapsed.\n   */\n  onChange?: (expandedIndex: ExpandedIndex) => void\n}\n\n/**\n * useAccordion hook provides all the state and focus management logic\n * for accordion items.\n */\nexport function useAccordion(props: UseAccordionProps) {\n  const {\n    onChange,\n    defaultIndex,\n    index: indexProp,\n    allowMultiple,\n    allowToggle,\n    ...htmlProps\n  } = props\n\n  // validate the props and `warn` if used incorrectly\n  allowMultipleWarning(props)\n  allowMultipleAndAllowToggleWarning(props)\n\n  /**\n   * Think of this as the register to each accordion item.\n   * We used to manage focus between accordion item buttons.\n   *\n   * Every accordion item, registers their button refs in this context\n   */\n  const domContext = useDescendants()\n\n  /**\n   * This state is used to track the index focused accordion\n   * button when click on the button, tab on the button, or\n   * use the down/up arrow to navigate.\n   */\n  const [focusedIndex, setFocusedIndex] = useState(-1)\n\n  /**\n   * Reset focused index when accordion unmounts\n   * or descendants change\n   */\n  useUnmountEffect(() => {\n    setFocusedIndex(-1)\n  }, [domContext.descendants])\n\n  /**\n   * Hook that manages the controlled and un-controlled state\n   * for the accordion.\n   */\n  const [index, setIndex] = useControllableState({\n    value: indexProp,\n    defaultValue: () => {\n      if (allowMultiple) return defaultIndex ?? []\n      return defaultIndex ?? -1\n    },\n    onChange,\n  })\n\n  /**\n   * Gets the `isOpen` and `onChange` props for a child accordion item based on\n   * the child's index.\n   *\n   * @param idx {number} The index of the child accordion item\n   */\n  const getAccordionItemProps = (idx: number | null) => {\n    let isOpen = false\n    if (idx !== null) {\n      isOpen = isArray(index) ? index.includes(idx) : index === idx\n    }\n\n    const onChange = (isOpen: boolean) => {\n      if (idx === null) return\n\n      if (allowMultiple && isArray(index)) {\n        const nextState = isOpen ? addItem(index, idx) : removeItem(index, idx)\n        setIndex(nextState)\n      } else if (isOpen) {\n        setIndex(idx)\n      } else if (allowToggle) {\n        setIndex(-1)\n      }\n    }\n\n    return { isOpen, onChange }\n  }\n\n  return {\n    index,\n    setIndex,\n    htmlProps,\n    getAccordionItemProps,\n    focusedIndex,\n    setFocusedIndex,\n    domContext,\n  }\n}\n\nexport type UseAccordionReturn = ReturnType<typeof useAccordion>\n\ninterface AccordionContext extends Omit<UseAccordionReturn, \"htmlProps\"> {\n  reduceMotion: boolean\n}\n\nconst [\n  AccordionProvider,\n  useAccordionContext,\n] = createContext<AccordionContext>({\n  name: \"AccordionContext\",\n  errorMessage:\n    \"useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`\",\n})\n\nexport { AccordionProvider, useAccordionContext }\n\nexport interface UseAccordionItemProps {\n  /**\n   * If `true`, the accordion item will be disabled.\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the accordion item will be focusable.\n   */\n  isFocusable?: boolean\n  /**\n   * A unique id for the accordion item.\n   */\n  id?: string\n}\n\n/**\n * useAccordionItem\n *\n * React hook that provides the open/close functionality\n * for an accordion item and its children\n */\nexport function useAccordionItem(props: UseAccordionItemProps) {\n  const { isDisabled, isFocusable, id, ...htmlProps } = props\n\n  const {\n    getAccordionItemProps,\n    domContext,\n    focusedIndex,\n    setFocusedIndex,\n  } = useAccordionContext()\n\n  const { descendants } = domContext\n\n  const buttonRef = useRef<HTMLElement>(null)\n\n  /**\n   * Generate unique ids for all accordion item components (button and panel)\n   */\n  const [buttonId, panelId] = useIds(id, `accordion-button`, `accordion-panel`)\n\n  focusableNotDisabledWarning(props)\n\n  /**\n   * Think of this as a way to register this accordion item\n   * with its parent `useAccordion`\n   */\n  const index = useDescendant({\n    element: buttonRef.current,\n    context: domContext,\n    disabled: isDisabled,\n    focusable: isFocusable,\n  })\n\n  const { isOpen, onChange } = getAccordionItemProps(\n    index === -1 ? null : index,\n  )\n\n  const onOpen = () => {\n    onChange?.(true)\n  }\n\n  const onClose = () => {\n    onChange?.(false)\n  }\n\n  const shouldFocus = index === focusedIndex\n\n  /**\n   * Autofocus the accordion button when\n   * the active index matched the accordion item's index\n   */\n  useFocusEffect(buttonRef, { shouldFocus })\n\n  /**\n   * Toggle the visibility of the accordion item\n   */\n  const onClick = useCallback(() => {\n    onChange?.(!isOpen)\n    setFocusedIndex(index)\n  }, [index, isOpen, onChange, setFocusedIndex])\n\n  /**\n   * Manage keyboard navigation between accordion items.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n\n      const keyMap: EventKeyMap = {\n        ArrowDown: () => {\n          const nextIndex = getNextIndex(index, descendants.length)\n          const nextAccordion = descendants[nextIndex]\n          nextAccordion?.element?.focus()\n        },\n        ArrowUp: () => {\n          const prevIndex = getPrevIndex(index, descendants.length)\n          const prevAccordion = descendants[prevIndex]\n          prevAccordion?.element?.focus()\n        },\n        Home: () => {\n          const firstAccordion = descendants[0]\n          firstAccordion?.element?.focus()\n        },\n        End: () => {\n          const lastAccordion = descendants[descendants.length - 1]\n          lastAccordion?.element?.focus()\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, index],\n  )\n\n  /**\n   * Since each accordion item's button still remains tabbable, let's\n   * update the focusedIndex when it receives focus\n   */\n  const onFocus = useCallback(() => setFocusedIndex(index), [\n    index,\n    setFocusedIndex,\n  ])\n\n  const getButtonProps: PropGetter<HTMLButtonElement> = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      type: \"button\",\n      ref: mergeRefs(buttonRef, ref),\n      id: buttonId,\n      disabled: !!isDisabled,\n      \"aria-expanded\": !!isOpen,\n      \"aria-controls\": panelId,\n      onClick: callAllHandlers(props.onClick, onClick),\n      onFocus: callAllHandlers(props.onFocus, onFocus),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n    }),\n    [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId],\n  )\n\n  const getPanelProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      role: \"region\",\n      id: panelId,\n      \"aria-labelledby\": buttonId,\n      hidden: !isOpen,\n    }),\n    [buttonId, isOpen, panelId],\n  )\n\n  return {\n    isOpen,\n    isDisabled,\n    isFocusable,\n    onOpen,\n    onClose,\n    getButtonProps,\n    getPanelProps,\n    htmlProps,\n  }\n}\n\nexport type UseAccordionItemReturn = ReturnType<typeof useAccordionItem>\n\nfunction allowMultipleWarning(props: UseAccordionProps) {\n  const index = props.index || props.defaultIndex\n  const condition =\n    !isUndefined(index) && !isArray(index) && props.allowMultiple\n\n  warn({\n    condition: !!condition,\n    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`,\n  })\n}\n\nfunction allowMultipleAndAllowToggleWarning(props: UseAccordionProps) {\n  warn({\n    condition: !!(props.allowMultiple && props.allowToggle),\n    message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`,\n  })\n}\n\nfunction focusableNotDisabledWarning(props: UseAccordionItemProps) {\n  warn({\n    condition: !!(props.isFocusable && !props.isDisabled),\n    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.\n    `,\n  })\n}\n"]},"metadata":{},"sourceType":"module"}