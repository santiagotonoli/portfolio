{"ast":null,"code":"import { getLastItem } from \"./array\";\nimport { isArray, isNumber, isObject } from \"./assertion\";\nimport { fromEntries, objectKeys } from \"./object\";\nexport var breakpoints = Object.freeze([\"base\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\"]);\nexport function mapResponsive(prop, mapper) {\n  if (isArray(prop)) {\n    return prop.map(item => {\n      if (item === null) {\n        return null;\n      }\n\n      return mapper(item);\n    });\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result, key) => {\n      result[key] = mapper(prop[key]);\n      return result;\n    }, {});\n  }\n\n  if (prop != null) {\n    return mapper(prop);\n  }\n\n  return null;\n}\nexport function objectToArrayNotation(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n\n  var result = bps.map(br => {\n    var _obj$br;\n\n    return (_obj$br = obj[br]) != null ? _obj$br : null;\n  });\n\n  while (getLastItem(result) === null) {\n    result.pop();\n  }\n\n  return result;\n}\nexport function arrayToObjectNotation(values, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n\n  var result = {};\n  values.forEach((value, index) => {\n    var key = bps[index];\n    if (value == null) return;\n    result[key] = value;\n  });\n  return result;\n}\nexport function isResponsiveObjectLike(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n\n  var keys = Object.keys(obj);\n  return keys.length > 0 && keys.every(key => bps.includes(key));\n}\n/**\n * @note\n * The code below is the recommended way to analyze breakpoints\n * related stuff. Avoid using functions above, it'll be removed in the\n * next major\n */\n\nvar analyzeCSSValue = value => {\n  var num = parseFloat(value.toString());\n  var unit = value.toString().replace(String(num), \"\");\n  return {\n    unitless: !unit,\n    value: num,\n    unit\n  };\n};\n\nexport var px = value => {\n  if (value == null) return value;\n  var {\n    unitless\n  } = analyzeCSSValue(value);\n  return unitless || isNumber(value) ? value + \"px\" : value;\n};\n\nvar sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;\n\nvar sortBps = breakpoints => fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));\n\nfunction normalize(breakpoints) {\n  var sorted = sortBps(breakpoints);\n  return Object.assign(Object.values(sorted), sorted);\n}\n\nfunction keys(breakpoints) {\n  var value = Object.keys(sortBps(breakpoints));\n  return new Set(value);\n}\n\nfunction subtract(value) {\n  if (!value) return value;\n  value = px(value);\n  var factor = value.endsWith(\"px\") ? -1 : // the equivalent of 1px in em using a 16px base\n  -0.0635;\n  return isNumber(value) ? \"\" + (value + factor) : value.replace(/([0-9]+\\.?[0-9]*)/, m => \"\" + (parseFloat(m) + factor));\n}\n\nfunction queryString(min, max) {\n  var query = [];\n  if (min) query.push(\"@media screen and (min-width: \" + px(min) + \")\");\n  if (query.length > 0 && max) query.push(\"and\");\n  if (max) query.push(\"@media screen and (max-width: \" + px(max) + \")\");\n  return query.join(\" \");\n}\n\nexport function analyzeBreakpoints(breakpoints) {\n  var _breakpoints$base;\n\n  if (!breakpoints) return null;\n  breakpoints.base = (_breakpoints$base = breakpoints.base) != null ? _breakpoints$base : \"0px\";\n  var normalized = normalize(breakpoints);\n  var queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map((_ref, index, entry) => {\n    var _entry;\n\n    var [breakpoint, minW] = _ref;\n    var [, maxW] = (_entry = entry[index + 1]) != null ? _entry : [];\n    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined;\n    return {\n      breakpoint,\n      minW,\n      maxW,\n      maxWQuery: queryString(null, maxW),\n      minWQuery: queryString(minW),\n      minMaxQuery: queryString(minW, maxW)\n    };\n  });\n\n  var _keys = keys(breakpoints);\n\n  var _keysArr = Array.from(_keys.values());\n\n  return {\n    keys: _keys,\n    normalized,\n\n    isResponsive(test) {\n      var keys = Object.keys(test);\n      return keys.length > 0 && keys.every(key => _keys.has(key));\n    },\n\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map(minW => queryString(minW)).slice(1)],\n\n    toArrayValue(test) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\");\n      }\n\n      var result = _keysArr.map(bp => {\n        var _test$bp;\n\n        return (_test$bp = test[bp]) != null ? _test$bp : null;\n      });\n\n      while (getLastItem(result) === null) {\n        result.pop();\n      }\n\n      return result;\n    },\n\n    toObjectValue(test) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\");\n      }\n\n      return test.reduce((acc, value, index) => {\n        var key = _keysArr[index];\n        if (key != null && value != null) acc[key] = value;\n        return acc;\n      }, {});\n    }\n\n  };\n}\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\n\nexport var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));","map":{"version":3,"mappings":"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","names":["getLastItem","isArray","isNumber","isObject","fromEntries","objectKeys","breakpoints","Object","freeze","mapResponsive","prop","mapper","map","item","reduce","result","key","objectToArrayNotation","obj","bps","br","pop","arrayToObjectNotation","values","forEach","value","index","isResponsiveObjectLike","keys","length","every","includes","analyzeCSSValue","num","parseFloat","toString","unit","replace","String","unitless","px","sortByBreakpointValue","a","b","parseInt","sortBps","entries","sort","normalize","sorted","assign","Set","subtract","factor","endsWith","m","queryString","min","max","query","push","join","analyzeBreakpoints","base","normalized","queries","entry","breakpoint","minW","_ref","maxW","undefined","maxWQuery","minWQuery","minMaxQuery","_keys","_keysArr","Array","from","isResponsive","test","has","asObject","asArray","details","media","slice","toArrayValue","Error","bp","toObjectValue","acc","isCustomBreakpoint","maybeBreakpoint","Number","isNaN"],"sources":["../../src/responsive.ts"],"sourcesContent":["import { getLastItem } from \"./array\"\nimport { isArray, isNumber, isObject } from \"./assertion\"\nimport { fromEntries, objectKeys } from \"./object\"\nimport { Dict } from \"./types\"\n\nexport const breakpoints = Object.freeze([\n  \"base\",\n  \"sm\",\n  \"md\",\n  \"lg\",\n  \"xl\",\n  \"2xl\",\n])\n\nexport function mapResponsive(prop: any, mapper: (val: any) => any) {\n  if (isArray(prop)) {\n    return prop.map((item) => {\n      if (item === null) {\n        return null\n      }\n      return mapper(item)\n    })\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result: Dict, key) => {\n      result[key] = mapper(prop[key])\n      return result\n    }, {})\n  }\n\n  if (prop != null) {\n    return mapper(prop)\n  }\n\n  return null\n}\n\nexport function objectToArrayNotation(obj: Dict, bps = breakpoints) {\n  const result = bps.map((br) => obj[br] ?? null)\n  while (getLastItem(result) === null) {\n    result.pop()\n  }\n  return result\n}\n\nexport function arrayToObjectNotation(values: any[], bps = breakpoints) {\n  const result = {} as Dict\n  values.forEach((value, index) => {\n    const key = bps[index]\n    if (value == null) return\n    result[key] = value\n  })\n  return result\n}\n\nexport function isResponsiveObjectLike(obj: Dict, bps = breakpoints) {\n  const keys = Object.keys(obj)\n  return keys.length > 0 && keys.every((key) => bps.includes(key))\n}\n\n/**\n * @note\n * The code below is the recommended way to analyze breakpoints\n * related stuff. Avoid using functions above, it'll be removed in the\n * next major\n */\n\nconst analyzeCSSValue = (value: number | string) => {\n  const num = parseFloat(value.toString())\n  const unit = value.toString().replace(String(num), \"\")\n  return { unitless: !unit, value: num, unit }\n}\n\nexport const px = (value: number | string): string => {\n  if (value == null) return value\n  const { unitless } = analyzeCSSValue(value)\n  return unitless || isNumber(value) ? `${value}px` : value\n}\n\nconst sortByBreakpointValue = (a: any[], b: any[]) =>\n  parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1\n\nconst sortBps = (breakpoints: Dict): Dict =>\n  fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue))\n\nfunction normalize(breakpoints: Dict) {\n  const sorted = sortBps(breakpoints)\n  return Object.assign(Object.values(sorted), sorted) as string[]\n}\n\nfunction keys(breakpoints: Dict) {\n  const value = Object.keys(sortBps(breakpoints))\n  return new Set(value)\n}\n\nfunction subtract(value: string) {\n  if (!value) return value\n  value = px(value)\n  const factor = value.endsWith(\"px\")\n    ? -1\n    : // the equivalent of 1px in em using a 16px base\n      -0.0635\n  return isNumber(value)\n    ? `${value + factor}`\n    : value.replace(/(\\d+\\.?\\d*)/u, (m) => `${parseFloat(m) + factor}`)\n}\n\nfunction queryString(min: string | null, max?: string) {\n  const query = []\n\n  if (min) query.push(`@media screen and (min-width: ${px(min)})`)\n  if (query.length > 0 && max) query.push(\"and\")\n  if (max) query.push(`@media screen and (max-width: ${px(max)})`)\n\n  return query.join(\" \")\n}\n\nexport function analyzeBreakpoints(breakpoints: Dict) {\n  if (!breakpoints) return null\n\n  breakpoints.base = breakpoints.base ?? \"0px\"\n\n  const normalized = normalize(breakpoints)\n\n  const queries = Object.entries(breakpoints)\n    .sort(sortByBreakpointValue)\n    .map(([breakpoint, minW], index, entry) => {\n      let [, maxW] = entry[index + 1] ?? []\n      maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined\n      return {\n        breakpoint,\n        minW,\n        maxW,\n        maxWQuery: queryString(null, maxW),\n        minWQuery: queryString(minW),\n        minMaxQuery: queryString(minW, maxW),\n      }\n    })\n\n  const _keys = keys(breakpoints)\n  const _keysArr = Array.from(_keys.values())\n\n  return {\n    keys: _keys,\n    normalized,\n    isResponsive(test: Dict) {\n      const keys = Object.keys(test)\n      return keys.length > 0 && keys.every((key) => _keys.has(key))\n    },\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map((minW) => queryString(minW)).slice(1)],\n    toArrayValue(test: Dict) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\")\n      }\n      const result = _keysArr.map((bp) => test[bp] ?? null)\n      while (getLastItem(result) === null) result.pop()\n      return result\n    },\n    toObjectValue(test: any[]) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\")\n      }\n      return test.reduce((acc, value, index) => {\n        const key = _keysArr[index]\n        if (key != null && value != null) acc[key] = value\n        return acc\n      }, {} as Dict)\n    },\n  }\n}\n\nexport type AnalyzeBreakpointsReturn = ReturnType<typeof analyzeBreakpoints>\n\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\nexport const isCustomBreakpoint = (maybeBreakpoint: string) =>\n  Number.isNaN(Number(maybeBreakpoint))\n"]},"metadata":{},"sourceType":"module"}