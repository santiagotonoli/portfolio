{"ast":null,"code":"import { getBoxShadow, toTransformOrigin, popperCSSVars as cssVars } from \"./utils\";\n/* -------------------------------------------------------------------------------------------------\n The match width modifier sets the popper width to match the reference.\n It us useful for custom selects, autocomplete, etc.\n* -----------------------------------------------------------------------------------------------*/\n\nexport var matchWidth = {\n  name: \"matchWidth\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  requires: [\"computeStyles\"],\n  fn: _ref => {\n    var {\n      state\n    } = _ref;\n    state.styles.popper.width = state.rects.reference.width + \"px\";\n  },\n  effect: _ref2 => {\n    var {\n      state\n    } = _ref2;\n    return () => {\n      var reference = state.elements.reference;\n      state.elements.popper.style.width = reference.offsetWidth + \"px\";\n    };\n  }\n};\n/* -------------------------------------------------------------------------------------------------\n  The transform origin modifier sets the css `transformOrigin` value of the popper\n  based on the dynamic placement state of the popper.\n  \n  Useful when we need to animate/transition the popper.\n* -----------------------------------------------------------------------------------------------*/\n\nexport var transformOrigin = {\n  name: \"transformOrigin\",\n  enabled: true,\n  phase: \"write\",\n  fn: _ref3 => {\n    var {\n      state\n    } = _ref3;\n    setTransformOrigin(state);\n  },\n  effect: _ref4 => {\n    var {\n      state\n    } = _ref4;\n    return () => {\n      setTransformOrigin(state);\n    };\n  }\n};\n\nvar setTransformOrigin = state => {\n  state.elements.popper.style.setProperty(cssVars.transformOrigin.var, toTransformOrigin(state.placement));\n};\n/* -------------------------------------------------------------------------------------------------\n  The position arrow modifier adds width, height and overrides the `top/left/right/bottom`\n  styles generated by popper.js to properly position the arrow\n* -----------------------------------------------------------------------------------------------*/\n\n\nexport var positionArrow = {\n  name: \"positionArrow\",\n  enabled: true,\n  phase: \"afterWrite\",\n  fn: _ref5 => {\n    var {\n      state\n    } = _ref5;\n    setArrowStyles(state);\n  }\n};\n\nvar setArrowStyles = state => {\n  var _state$elements;\n\n  if (!state.placement) return;\n  var overrides = getArrowStyle(state.placement);\n\n  if ((_state$elements = state.elements) != null && _state$elements.arrow && overrides) {\n    Object.assign(state.elements.arrow.style, {\n      [overrides.property]: overrides.value,\n      width: cssVars.arrowSize.varRef,\n      height: cssVars.arrowSize.varRef,\n      zIndex: -1\n    });\n    var vars = {\n      [cssVars.arrowSizeHalf.var]: \"calc(\" + cssVars.arrowSize.varRef + \" / 2)\",\n      [cssVars.arrowOffset.var]: \"calc(\" + cssVars.arrowSizeHalf.varRef + \" * -1)\"\n    };\n\n    for (var property in vars) {\n      state.elements.arrow.style.setProperty(property, vars[property]);\n    }\n  }\n};\n\nvar getArrowStyle = placement => {\n  if (placement.startsWith(\"top\")) {\n    return {\n      property: \"bottom\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n\n  if (placement.startsWith(\"bottom\")) {\n    return {\n      property: \"top\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n\n  if (placement.startsWith(\"left\")) {\n    return {\n      property: \"right\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n\n  if (placement.startsWith(\"right\")) {\n    return {\n      property: \"left\",\n      value: cssVars.arrowOffset.varRef\n    };\n  }\n};\n/* -------------------------------------------------------------------------------------------------\n  The inner arrow modifier, sets the placement styles for the inner arrow that forms\n  the popper arrow tip.\n* -----------------------------------------------------------------------------------------------*/\n\n\nexport var innerArrow = {\n  name: \"innerArrow\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"arrow\"],\n  fn: _ref6 => {\n    var {\n      state\n    } = _ref6;\n    setInnerArrowStyles(state);\n  },\n  effect: _ref7 => {\n    var {\n      state\n    } = _ref7;\n    return () => {\n      setInnerArrowStyles(state);\n    };\n  }\n};\n\nvar setInnerArrowStyles = state => {\n  if (!state.elements.arrow) return;\n  var inner = state.elements.arrow.querySelector(\"[data-popper-arrow-inner]\");\n  if (!inner) return;\n  Object.assign(inner.style, {\n    transform: \"rotate(45deg)\",\n    background: cssVars.arrowBg.varRef,\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    position: \"absolute\",\n    zIndex: \"inherit\",\n    boxShadow: getBoxShadow(state.placement)\n  });\n};","map":{"version":3,"mappings":"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","names":["getBoxShadow","toTransformOrigin","popperCSSVars","cssVars","matchWidth","name","enabled","phase","requires","fn","_ref","state","styles","popper","width","rects","reference","effect","_ref2","elements","style","offsetWidth","transformOrigin","_ref3","setTransformOrigin","_ref4","setProperty","var","placement","positionArrow","_ref5","setArrowStyles","overrides","getArrowStyle","arrow","Object","assign","property","value","arrowSize","varRef","height","zIndex","vars","arrowSizeHalf","arrowOffset","startsWith","innerArrow","_ref6","setInnerArrowStyles","_ref7","inner","querySelector","transform","background","arrowBg","top","left","position","boxShadow"],"sources":["../../src/modifiers.ts"],"sourcesContent":["import { Placement, Modifier, State } from \"@popperjs/core\"\nimport {\n  getBoxShadow,\n  toTransformOrigin,\n  popperCSSVars as cssVars,\n} from \"./utils\"\n\n/* -------------------------------------------------------------------------------------------------\n The match width modifier sets the popper width to match the reference.\n It us useful for custom selects, autocomplete, etc.\n* -----------------------------------------------------------------------------------------------*/\n\nexport const matchWidth: Modifier<\"matchWidth\", any> = {\n  name: \"matchWidth\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  requires: [\"computeStyles\"],\n  fn: ({ state }) => {\n    state.styles.popper.width = `${state.rects.reference.width}px`\n  },\n  effect: ({ state }) => () => {\n    const reference = state.elements.reference as HTMLElement\n    state.elements.popper.style.width = `${reference.offsetWidth}px`\n  },\n}\n\n/* -------------------------------------------------------------------------------------------------\n  The transform origin modifier sets the css `transformOrigin` value of the popper\n  based on the dynamic placement state of the popper.\n  \n  Useful when we need to animate/transition the popper.\n* -----------------------------------------------------------------------------------------------*/\n\nexport const transformOrigin: Modifier<\"transformOrigin\", any> = {\n  name: \"transformOrigin\",\n  enabled: true,\n  phase: \"write\",\n  fn: ({ state }) => {\n    setTransformOrigin(state)\n  },\n  effect: ({ state }) => () => {\n    setTransformOrigin(state)\n  },\n}\n\nconst setTransformOrigin = (state: State) => {\n  state.elements.popper.style.setProperty(\n    cssVars.transformOrigin.var,\n    toTransformOrigin(state.placement),\n  )\n}\n\n/* -------------------------------------------------------------------------------------------------\n  The position arrow modifier adds width, height and overrides the `top/left/right/bottom`\n  styles generated by popper.js to properly position the arrow\n* -----------------------------------------------------------------------------------------------*/\n\nexport const positionArrow: Modifier<\"positionArrow\", any> = {\n  name: \"positionArrow\",\n  enabled: true,\n  phase: \"afterWrite\",\n  fn: ({ state }) => {\n    setArrowStyles(state)\n  },\n}\n\nconst setArrowStyles = (state: Partial<State>) => {\n  if (!state.placement) return\n  const overrides = getArrowStyle(state.placement)\n\n  if (state.elements?.arrow && overrides) {\n    Object.assign(state.elements.arrow.style, {\n      [overrides.property]: overrides.value,\n      width: cssVars.arrowSize.varRef,\n      height: cssVars.arrowSize.varRef,\n      zIndex: -1,\n    })\n\n    const vars = {\n      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2)`,\n      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`,\n    }\n\n    for (const property in vars) {\n      state.elements.arrow.style.setProperty(property, vars[property])\n    }\n  }\n}\n\nconst getArrowStyle = (placement: Placement) => {\n  if (placement.startsWith(\"top\")) {\n    return { property: \"bottom\", value: cssVars.arrowOffset.varRef }\n  }\n  if (placement.startsWith(\"bottom\")) {\n    return { property: \"top\", value: cssVars.arrowOffset.varRef }\n  }\n  if (placement.startsWith(\"left\")) {\n    return { property: \"right\", value: cssVars.arrowOffset.varRef }\n  }\n  if (placement.startsWith(\"right\")) {\n    return { property: \"left\", value: cssVars.arrowOffset.varRef }\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n  The inner arrow modifier, sets the placement styles for the inner arrow that forms\n  the popper arrow tip.\n* -----------------------------------------------------------------------------------------------*/\n\nexport const innerArrow: Modifier<\"innerArrow\", any> = {\n  name: \"innerArrow\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"arrow\"],\n  fn: ({ state }) => {\n    setInnerArrowStyles(state)\n  },\n  effect: ({ state }) => () => {\n    setInnerArrowStyles(state)\n  },\n}\n\nconst setInnerArrowStyles = (state: State) => {\n  if (!state.elements.arrow) return\n\n  const inner = state.elements.arrow.querySelector(\n    \"[data-popper-arrow-inner]\",\n  ) as HTMLElement | null\n\n  if (!inner) return\n\n  Object.assign(inner.style, {\n    transform: \"rotate(45deg)\",\n    background: cssVars.arrowBg.varRef,\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    position: \"absolute\",\n    zIndex: \"inherit\",\n    boxShadow: getBoxShadow(state.placement),\n  })\n}\n"]},"metadata":{},"sourceType":"module"}