{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { useState, useCallback } from \"react\";\nimport { useControllableProp } from \"@chakra-ui/hooks\";\nimport { isInputEvent, addItem, removeItem } from \"@chakra-ui/utils\";\n/**\n * React hook that provides all the state management logic\n * for a group of checkboxes.\n *\n * It is consumed by the `CheckboxGroup` component\n */\n\nexport function useCheckboxGroup(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n    isNative\n  } = props;\n  var [valueState, setValue] = useState(defaultValue || []);\n  var [isControlled, value] = useControllableProp(valueProp, valueState);\n  var updateValue = useCallback(nextState => {\n    if (!isControlled) {\n      setValue(nextState);\n    }\n\n    onChangeProp == null ? void 0 : onChangeProp(nextState);\n  }, [isControlled, onChangeProp]);\n  var onChange = useCallback(eventOrValue => {\n    if (!value) return;\n    var isChecked = isInputEvent(eventOrValue) ? eventOrValue.target.checked : !value.includes(eventOrValue);\n    var selectedValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;\n    var nextValue = isChecked ? addItem(value, selectedValue) : removeItem(value, selectedValue);\n    updateValue(nextValue);\n  }, [updateValue, value]);\n  return {\n    value,\n    onChange,\n    setValue: updateValue,\n    getCheckboxProps: function getCheckboxProps(props) {\n      if (props === void 0) {\n        props = {};\n      }\n\n      var checkedKey = isNative ? \"checked\" : \"isChecked\";\n      return _extends({}, props, {\n        [checkedKey]: value.includes(props.value),\n        onChange\n      });\n    }\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAAA,SAASA,QAAT,EAAmBC,WAAnB,QAAmD,OAAnD;AACA,SAASC,mBAAT,QAAoC,kBAApC;AACA,SACEC,YADF,EAEEC,OAFF,EAGEC,UAHF,QAMO,kBANP;AAgCA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,gBAAT,CAA0BC,KAA1B,EAA6D;EAAA,IAAnCA,KAAmC;IAAnCA,KAAmC,GAAJ,EAA/BA;EAAmC;;EAClE,IAAM;IACJC,YADI;IAEJC,KAAK,EAAEC,SAFH;IAGJC,QAAQ,EAAEC,YAHN;IAIJC;EAJI,IAKFN,KALJ;EAOA,IAAM,CAACO,UAAD,EAAaC,QAAb,IAAyBf,QAAQ,CAACQ,YAAY,IAAI,EAAjB,CAAvC;EACA,IAAM,CAACQ,YAAD,EAAeP,KAAf,IAAwBP,mBAAmB,CAACQ,SAAD,EAAYI,UAAZ,CAAjD;EAEA,IAAMG,WAAW,GAAGhB,WAAW,CAC5BiB,SAAD,IAAiC;IAC/B,IAAI,CAACF,YAAL,EAAmB;MACjBD,QAAQ,CAACG,SAAD,CAARH;IACD;;IAEDH,YAAY,QAAZA,wBAAY,CAAGM,SAAH,CAAZN;EAN2B,GAQ7B,CAACI,YAAD,EAAeJ,YAAf,CAR6B,CAA/B;EAWA,IAAMD,QAAQ,GAAGV,WAAW,CACzBkB,YAAD,IAAgC;IAC9B,IAAI,CAACV,KAAL,EAAY;IAEZ,IAAMW,SAAS,GAAGjB,YAAY,CAACgB,YAAD,CAAZhB,GACdgB,YAAY,CAACE,MAAbF,CAAoBG,OADNnB,GAEd,CAACM,KAAK,CAACc,QAANd,CAAeU,YAAfV,CAFL;IAIA,IAAMe,aAAa,GAAGrB,YAAY,CAACgB,YAAD,CAAZhB,GAClBgB,YAAY,CAACE,MAAbF,CAAoBV,KADFN,GAElBgB,YAFJ;IAIA,IAAMM,SAAS,GAAGL,SAAS,GACvBhB,OAAO,CAACK,KAAD,EAAQe,aAAR,CADgB,GAEvBnB,UAAU,CAACI,KAAD,EAAQe,aAAR,CAFd;IAIAP,WAAW,CAACQ,SAAD,CAAXR;EAhBwB,GAkB1B,CAACA,WAAD,EAAcR,KAAd,CAlB0B,CAA5B;EAqBA,OAAO;IACLA,KADK;IAELE,QAFK;IAGLI,QAAQ,EAAEE,WAHL;IAILS,gBAAgB,EAAE,0BAACnB,KAAD,EAAsB;MAAA,IAArBA,KAAqB;QAArBA,KAAqB,GAAP,EAAdA;MAAqB;;MACtC,IAAMoB,UAAU,GAAGd,QAAQ,GAAG,SAAH,GAAe,WAA1C;MACA,oBACKN,KADL;QAEE,CAACoB,UAAD,GAAclB,KAAK,CAACc,QAANd,CAAeF,KAAK,CAACE,KAArBA,CAFhB;QAGEE;MAHF;IAKD;EAXI,CAAP;AAaD","names":["useState","useCallback","useControllableProp","isInputEvent","addItem","removeItem","useCheckboxGroup","props","defaultValue","value","valueProp","onChange","onChangeProp","isNative","valueState","setValue","isControlled","updateValue","nextState","eventOrValue","isChecked","target","checked","includes","selectedValue","nextValue","getCheckboxProps","checkedKey"],"sources":["../../src/use-checkbox-group.ts"],"sourcesContent":["import { useState, useCallback, ChangeEvent } from \"react\"\nimport { useControllableProp } from \"@chakra-ui/hooks\"\nimport {\n  isInputEvent,\n  addItem,\n  removeItem,\n  StringOrNumber,\n  Dict,\n} from \"@chakra-ui/utils\"\n\ntype EventOrValue = ChangeEvent<HTMLInputElement> | StringOrNumber\n\nexport interface UseCheckboxGroupProps {\n  /**\n   * The value of the checkbox group\n   */\n  value?: StringOrNumber[]\n  /**\n   * The initial value of the checkbox group\n   */\n  defaultValue?: StringOrNumber[]\n  /**\n   * The callback fired when any children Checkbox is checked or unchecked\n   */\n  onChange?(value: StringOrNumber[]): void\n  /**\n   * If `true`, input elements will receive\n   * `checked` attribute instead of `isChecked`.\n   *\n   * This assumes, you're using native radio inputs\n   */\n  isNative?: boolean\n}\n\n/**\n * React hook that provides all the state management logic\n * for a group of checkboxes.\n *\n * It is consumed by the `CheckboxGroup` component\n */\nexport function useCheckboxGroup(props: UseCheckboxGroupProps = {}) {\n  const {\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n    isNative,\n  } = props\n\n  const [valueState, setValue] = useState(defaultValue || [])\n  const [isControlled, value] = useControllableProp(valueProp, valueState)\n\n  const updateValue = useCallback(\n    (nextState: StringOrNumber[]) => {\n      if (!isControlled) {\n        setValue(nextState)\n      }\n\n      onChangeProp?.(nextState)\n    },\n    [isControlled, onChangeProp],\n  )\n\n  const onChange = useCallback(\n    (eventOrValue: EventOrValue) => {\n      if (!value) return\n\n      const isChecked = isInputEvent(eventOrValue)\n        ? eventOrValue.target.checked\n        : !value.includes(eventOrValue)\n\n      const selectedValue = isInputEvent(eventOrValue)\n        ? eventOrValue.target.value\n        : eventOrValue\n\n      const nextValue = isChecked\n        ? addItem(value, selectedValue)\n        : removeItem(value, selectedValue)\n\n      updateValue(nextValue)\n    },\n    [updateValue, value],\n  )\n\n  return {\n    value,\n    onChange,\n    setValue: updateValue,\n    getCheckboxProps: (props: Dict = {}) => {\n      const checkedKey = isNative ? \"checked\" : \"isChecked\"\n      return {\n        ...props,\n        [checkedKey]: value.includes(props.value),\n        onChange,\n      }\n    },\n  }\n}\n\nexport type UseCheckboxGroupReturn = ReturnType<typeof useCheckboxGroup>\n"]},"metadata":{},"sourceType":"module"}