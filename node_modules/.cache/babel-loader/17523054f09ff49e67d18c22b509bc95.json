{"ast":null,"code":"// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\nimport { getOwnerDocument } from \"./dom\";\nimport { warn } from \"./function\";\nimport { isActiveElement, isInputElement } from \"./tabbable\";\nexport function focus(element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var {\n    isActive = isActiveElement,\n    nextTick,\n    preventScroll = true,\n    selectTextIfInput = true\n  } = options;\n  if (!element || isActive(element)) return -1;\n\n  function triggerFocus() {\n    if (!element) {\n      warn(\"[chakra-ui]: can't call focus() on `null` or `undefined` element\");\n      return;\n    }\n\n    if (supportsPreventScroll()) {\n      element.focus({\n        preventScroll\n      });\n    } else {\n      element.focus();\n\n      if (preventScroll) {\n        var scrollableElements = getScrollableElements(element);\n        restoreScrollPosition(scrollableElements);\n      }\n    }\n\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select();\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus);\n  }\n\n  triggerFocus();\n  return -1;\n}\nvar supportsPreventScrollCached = null;\n\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false;\n\n    try {\n      var div = document.createElement(\"div\");\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true;\n          return true;\n        }\n\n      });\n    } catch (e) {// Ignore\n    }\n  }\n\n  return supportsPreventScrollCached;\n}\n\nfunction getScrollableElements(element) {\n  var doc = getOwnerDocument(element);\n  var parent = element.parentNode;\n  var scrollableElements = [];\n  var rootScrollingElement = doc.scrollingElement || doc.documentElement;\n\n  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {\n    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft\n      });\n    }\n\n    parent = parent.parentNode;\n  }\n\n  if (rootScrollingElement instanceof HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft\n    });\n  }\n\n  return scrollableElements;\n}\n\nfunction restoreScrollPosition(scrollableElements) {\n  for (var {\n    element,\n    scrollTop,\n    scrollLeft\n  } of scrollableElements) {\n    element.scrollTop = scrollTop;\n    element.scrollLeft = scrollLeft;\n  }\n}","map":{"version":3,"mappings":"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","names":["getOwnerDocument","warn","isActiveElement","isInputElement","focus","element","options","isActive","nextTick","preventScroll","selectTextIfInput","triggerFocus","supportsPreventScroll","scrollableElements","getScrollableElements","restoreScrollPosition","select","requestAnimationFrame","supportsPreventScrollCached","div","document","createElement","e","doc","parent","parentNode","rootScrollingElement","scrollingElement","documentElement","HTMLElement","offsetHeight","scrollHeight","offsetWidth","scrollWidth","push","scrollTop","scrollLeft"],"sources":["../../src/focus.ts"],"sourcesContent":["// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\n\nimport { getOwnerDocument } from \"./dom\"\nimport { warn } from \"./function\"\nimport { FocusableElement, isActiveElement, isInputElement } from \"./tabbable\"\n\nexport interface ExtendedFocusOptions extends FocusOptions {\n  /**\n   * Function that determines if the element is the active element\n   */\n  isActive?: typeof isActiveElement\n  /**\n   * If true, the element will be focused in the next tick\n   */\n  nextTick?: boolean\n  /**\n   * If true and element is an input element, the input's text will be selected\n   */\n  selectTextIfInput?: boolean\n}\n\nexport function focus(\n  element: FocusableElement | null,\n  options: ExtendedFocusOptions = {},\n) {\n  const {\n    isActive = isActiveElement,\n    nextTick,\n    preventScroll = true,\n    selectTextIfInput = true,\n  } = options\n\n  if (!element || isActive(element)) return -1\n\n  function triggerFocus() {\n    if (!element) {\n      warn(\"[chakra-ui]: can't call focus() on `null` or `undefined` element\")\n      return\n    }\n    if (supportsPreventScroll()) {\n      element.focus({ preventScroll })\n    } else {\n      element.focus()\n      if (preventScroll) {\n        const scrollableElements = getScrollableElements(element as HTMLElement)\n        restoreScrollPosition(scrollableElements)\n      }\n    }\n\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select()\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus)\n  }\n\n  triggerFocus()\n  return -1\n}\n\nlet supportsPreventScrollCached: boolean | null = null\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false\n    try {\n      const div = document.createElement(\"div\")\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true\n          return true\n        },\n      })\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached\n}\n\ninterface ScrollableElement {\n  element: HTMLElement\n  scrollTop: number\n  scrollLeft: number\n}\n\nfunction getScrollableElements(element: HTMLElement): ScrollableElement[] {\n  const doc = getOwnerDocument(element)\n  let parent = element.parentNode\n  const scrollableElements: ScrollableElement[] = []\n  const rootScrollingElement = doc.scrollingElement || doc.documentElement\n\n  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft,\n      })\n    }\n    parent = parent.parentNode\n  }\n\n  if (rootScrollingElement instanceof HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft,\n    })\n  }\n\n  return scrollableElements\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (const { element, scrollTop, scrollLeft } of scrollableElements) {\n    element.scrollTop = scrollTop\n    element.scrollLeft = scrollLeft\n  }\n}\n"]},"metadata":{},"sourceType":"module"}