{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\";\nimport { useControllableState, useId } from \"@chakra-ui/hooks\";\nimport { ariaAttr, callAllHandlers, createContext, mergeRefs } from \"@chakra-ui/utils\";\nimport * as React from \"react\";\nvar [PinInputProvider, usePinInputContext] = createContext({\n  name: \"PinInputContext\",\n  errorMessage: \"usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`\"\n});\nexport { PinInputProvider, usePinInputContext };\n\nvar toArray = value => value == null ? void 0 : value.split(\"\");\n\nfunction validate(value, type) {\n  var NUMERIC_REGEX = /^[0-9]+$/;\n  var ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;\n  var regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;\n  return regex.test(value);\n}\n\nexport function usePinInput(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    autoFocus,\n    value,\n    defaultValue,\n    onChange: _onChange,\n    onComplete,\n    placeholder = \"â—‹\",\n    manageFocus = true,\n    otp = false,\n    id: idProp,\n    isDisabled,\n    isInvalid,\n    type = \"number\",\n    mask\n  } = props;\n  var uuid = useId();\n  var id = idProp != null ? idProp : \"pin-input-\" + uuid;\n  var domContext = useDescendants();\n  var {\n    descendants\n  } = domContext;\n  var [moveFocus, setMoveFocus] = React.useState(true);\n  var [values, setValues] = useControllableState({\n    defaultValue: toArray(defaultValue) || [],\n    value: toArray(value),\n    onChange: values => _onChange == null ? void 0 : _onChange(values.join(\"\"))\n  });\n  React.useEffect(() => {\n    if (autoFocus) {\n      var _firstInput$element;\n\n      var firstInput = descendants[0];\n      firstInput == null ? void 0 : (_firstInput$element = firstInput.element) == null ? void 0 : _firstInput$element.focus();\n    } // We don't want to listen for updates to `autoFocus` since it only runs initially\n    // eslint-disable-next-line\n\n  }, [descendants]);\n  var focusNext = React.useCallback(index => {\n    var _nextInput$element;\n\n    if (!moveFocus || !manageFocus) return;\n    var nextInput = descendants[index + 1];\n    nextInput == null ? void 0 : (_nextInput$element = nextInput.element) == null ? void 0 : _nextInput$element.focus();\n  }, [descendants, moveFocus, manageFocus]);\n  var setValue = React.useCallback((value, index) => {\n    var nextValues = [...values];\n    nextValues[index] = value;\n    setValues(nextValues);\n    var isComplete = value !== \"\" && index === descendants.length - 1 && nextValues.every(inputValue => inputValue !== \"\");\n\n    if (isComplete) {\n      onComplete == null ? void 0 : onComplete(nextValues.join(\"\"));\n    } else {\n      focusNext(index);\n    }\n  }, [values, setValues, focusNext, onComplete, descendants.length]);\n  var clear = React.useCallback(() => {\n    var _firstInput$element2;\n\n    var values = Array(descendants.length).fill(\"\");\n    setValues(values);\n    var firstInput = descendants[0];\n    (_firstInput$element2 = firstInput.element) == null ? void 0 : _firstInput$element2.focus();\n  }, [descendants, setValues]);\n  var getNextValue = React.useCallback((value, eventValue) => {\n    var nextValue = eventValue;\n\n    if ((value == null ? void 0 : value.length) > 0) {\n      if (value[0] === eventValue.charAt(0)) {\n        nextValue = eventValue.charAt(1);\n      } else if (value[0] === eventValue.charAt(1)) {\n        nextValue = eventValue.charAt(0);\n      }\n    }\n\n    return nextValue;\n  }, []);\n  var [focusedIndex, setFocusedIndex] = React.useState(-1);\n  var getInputProps = React.useCallback(props => {\n    var {\n      index\n    } = props,\n        rest = _objectWithoutPropertiesLoose(props, [\"index\"]);\n    /**\n     * Improved from: https://github.com/uber/baseweb/blob/master/src/pin-code/pin-code.js\n     */\n\n\n    var onChange = event => {\n      var eventValue = event.target.value;\n      var currentValue = values[index];\n      var nextValue = getNextValue(currentValue, eventValue); // if the value was removed using backspace\n\n      if (nextValue === \"\") {\n        setValue(\"\", index);\n        return;\n      } // in the case of an autocomplete or copy and paste\n\n\n      if (eventValue.length > 2) {\n        // see if we can use the string to fill out our values\n        if (validate(eventValue, type)) {\n          // Ensure the value matches the number of inputs\n          var _nextValue = eventValue.split(\"\").filter((_, index) => index < descendants.length);\n\n          setValues(_nextValue); // if pasting fills the entire input fields, trigger `onComplete`\n\n          if (_nextValue.length === descendants.length) {\n            onComplete == null ? void 0 : onComplete(_nextValue.join(\"\"));\n          }\n        }\n      } else {\n        // only set if the new value is a number\n        if (validate(nextValue, type)) {\n          setValue(nextValue, index);\n        }\n\n        setMoveFocus(true);\n      }\n    };\n\n    var onKeyDown = event => {\n      if (event.key === \"Backspace\" && manageFocus) {\n        if (event.target.value === \"\") {\n          var prevInput = descendants[index - 1];\n\n          if (prevInput) {\n            var _prevInput$element;\n\n            setValue(\"\", index - 1);\n            (_prevInput$element = prevInput.element) == null ? void 0 : _prevInput$element.focus();\n            setMoveFocus(true);\n          }\n        } else {\n          setMoveFocus(false);\n        }\n      }\n    };\n\n    var onFocus = () => {\n      setFocusedIndex(index);\n    };\n\n    var onBlur = () => {\n      setFocusedIndex(-1);\n    };\n\n    var hasFocus = focusedIndex === index;\n    var inputType = type === \"number\" ? \"tel\" : \"text\";\n    return _extends({\n      \"aria-label\": \"Please enter your pin code\",\n      inputMode: type === \"number\" ? \"numeric\" : \"text\",\n      type: mask ? \"password\" : inputType\n    }, rest, {\n      id: id + \"-\" + index,\n      disabled: isDisabled,\n      \"aria-invalid\": ariaAttr(isInvalid),\n      onChange: callAllHandlers(rest.onChange, onChange),\n      onKeyDown: callAllHandlers(rest.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(rest.onFocus, onFocus),\n      onBlur: callAllHandlers(rest.onBlur, onBlur),\n      value: values[index] || \"\",\n      autoComplete: otp ? \"one-time-code\" : \"off\",\n      placeholder: hasFocus ? \"\" : placeholder\n    });\n  }, [descendants, focusedIndex, getNextValue, id, isDisabled, mask, isInvalid, manageFocus, onComplete, otp, placeholder, setValue, setValues, type, values]);\n  return {\n    // prop getter\n    getInputProps,\n    // state\n    id,\n    domContext,\n    values,\n    // actions\n    setValue,\n    setValues,\n    clear\n  };\n}\nexport function usePinInputField(props, forwardedRef) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  if (forwardedRef === void 0) {\n    forwardedRef = null;\n  }\n\n  var ref = React.useRef(null);\n  var {\n    domContext,\n    getInputProps\n  } = usePinInputContext();\n  var index = useDescendant({\n    context: domContext,\n    element: ref.current\n  });\n  return getInputProps(_extends({}, props, {\n    ref: mergeRefs(ref, forwardedRef),\n    index\n  }));\n}","map":{"version":3,"mappings":"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","names":["useDescendant","useDescendants","useControllableState","useId","ariaAttr","callAllHandlers","createContext","mergeRefs","React","PinInputProvider","usePinInputContext","name","errorMessage","toArray","value","split","validate","type","NUMERIC_REGEX","ALPHA_NUMERIC_REGEX","regex","test","usePinInput","props","autoFocus","defaultValue","onChange","onComplete","placeholder","manageFocus","otp","id","idProp","isDisabled","isInvalid","mask","uuid","domContext","descendants","moveFocus","setMoveFocus","useState","values","setValues","join","useEffect","firstInput","element","focus","focusNext","useCallback","index","nextInput","setValue","nextValues","isComplete","length","every","inputValue","clear","Array","fill","getNextValue","eventValue","nextValue","charAt","focusedIndex","setFocusedIndex","getInputProps","rest","event","target","currentValue","filter","_","onKeyDown","key","prevInput","onFocus","onBlur","hasFocus","inputType","inputMode","disabled","autoComplete","usePinInputField","forwardedRef","ref","useRef","context","current"],"sources":["../../src/use-pin-input.ts"],"sourcesContent":["import { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport { useControllableState, useId } from \"@chakra-ui/hooks\"\nimport {\n  ariaAttr,\n  callAllHandlers,\n  createContext,\n  mergeRefs,\n} from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\ntype InputProps = Omit<\n  React.ComponentPropsWithRef<\"input\">,\n  \"color\" | \"height\" | \"width\"\n>\n\nexport type PinInputContext = UsePinInputReturn & {\n  /**\n   * Sets the pin input component to the disabled state\n   */\n  isDisabled?: boolean\n  /**\n   * Sets the pin input component to the invalid state\n   */\n  isInvalid?: boolean\n}\n\nconst [PinInputProvider, usePinInputContext] = createContext<PinInputContext>({\n  name: \"PinInputContext\",\n  errorMessage:\n    \"usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`\",\n})\n\nexport { PinInputProvider, usePinInputContext }\n\nexport interface UsePinInputProps {\n  /**\n   * If `true`, the pin input receives focus on mount\n   */\n  autoFocus?: boolean\n  /**\n   * The value of the the pin input. This is the value\n   * that will be returned when the pin input is filled\n   */\n  value?: string\n  /**\n   * The default value of the pin input\n   */\n  defaultValue?: string\n  /**\n   * Function called on input change\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when all inputs have valid values\n   */\n  onComplete?: (value: string) => void\n  /**\n   * The placeholder for the pin input\n   */\n  placeholder?: string\n  /**\n   * If `true`, focus will move automatically to the next input once filled\n   * @default true\n   */\n  manageFocus?: boolean\n  /**\n   * If `true`, the pin input component signals to its fields that they should\n   * use `autocomplete=\"one-time-code\"`.\n   */\n  otp?: boolean\n  /**\n   * The top-level id string that will be applied to the input fields.\n   * The index of the input will be appended to this top-level id.\n   *\n   * @example\n   * if id=\"foo\", the first input will have `foo-0`\n   */\n  id?: string\n  /**\n   * If `true`, the pin input component is put in the disabled state\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the pin input component is put in the invalid state\n   */\n  isInvalid?: boolean\n  /**\n   * The type of values the pin-input should allow\n   */\n  type?: \"alphanumeric\" | \"number\"\n  /**\n   * If `true`, the input's value will be masked just like `type=password`\n   */\n  mask?: boolean\n}\n\nconst toArray = (value?: string) => value?.split(\"\")\n\nfunction validate(value: string, type: UsePinInputProps[\"type\"]) {\n  const NUMERIC_REGEX = /^[0-9]+$/\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX\n  return regex.test(value)\n}\n\nexport function usePinInput(props: UsePinInputProps = {}) {\n  const {\n    autoFocus,\n    value,\n    defaultValue,\n    onChange,\n    onComplete,\n    placeholder = \"â—‹\",\n    manageFocus = true,\n    otp = false,\n    id: idProp,\n    isDisabled,\n    isInvalid,\n    type = \"number\",\n    mask,\n  } = props\n\n  const uuid = useId()\n  const id = idProp ?? `pin-input-${uuid}`\n\n  const domContext = useDescendants<HTMLInputElement, {}>()\n  const { descendants } = domContext\n\n  const [moveFocus, setMoveFocus] = React.useState(true)\n\n  const [values, setValues] = useControllableState<string[]>({\n    defaultValue: toArray(defaultValue) || [],\n    value: toArray(value),\n    onChange: (values) => onChange?.(values.join(\"\")),\n  })\n\n  React.useEffect(() => {\n    if (autoFocus) {\n      const firstInput = descendants[0]\n      firstInput?.element?.focus()\n    }\n    // We don't want to listen for updates to `autoFocus` since it only runs initially\n    // eslint-disable-next-line\n  }, [descendants])\n\n  const focusNext = React.useCallback(\n    (index: number) => {\n      if (!moveFocus || !manageFocus) return\n\n      const nextInput = descendants[index + 1]\n      nextInput?.element?.focus()\n    },\n    [descendants, moveFocus, manageFocus],\n  )\n\n  const setValue = React.useCallback(\n    (value: string, index: number) => {\n      const nextValues = [...values]\n      nextValues[index] = value\n      setValues(nextValues)\n\n      const isComplete =\n        value !== \"\" &&\n        index === descendants.length - 1 &&\n        nextValues.every((inputValue) => inputValue !== \"\")\n\n      if (isComplete) {\n        onComplete?.(nextValues.join(\"\"))\n      } else {\n        focusNext(index)\n      }\n    },\n    [values, setValues, focusNext, onComplete, descendants.length],\n  )\n\n  const clear = React.useCallback(() => {\n    const values: string[] = Array(descendants.length).fill(\"\")\n    setValues(values)\n    const firstInput = descendants[0]\n    firstInput.element?.focus()\n  }, [descendants, setValues])\n\n  const getNextValue = React.useCallback(\n    (value: string, eventValue: string) => {\n      let nextValue = eventValue\n      if (value?.length > 0) {\n        if (value[0] === eventValue.charAt(0)) {\n          nextValue = eventValue.charAt(1)\n        } else if (value[0] === eventValue.charAt(1)) {\n          nextValue = eventValue.charAt(0)\n        }\n      }\n      return nextValue\n    },\n    [],\n  )\n\n  const [focusedIndex, setFocusedIndex] = React.useState(-1)\n\n  const getInputProps = React.useCallback(\n    (props: InputProps & { index: number }): InputProps => {\n      const { index, ...rest } = props\n\n      /**\n       * Improved from: https://github.com/uber/baseweb/blob/master/src/pin-code/pin-code.js\n       */\n      const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const eventValue = event.target.value\n        const currentValue = values[index]\n        const nextValue = getNextValue(currentValue, eventValue)\n\n        // if the value was removed using backspace\n        if (nextValue === \"\") {\n          setValue(\"\", index)\n          return\n        }\n\n        // in the case of an autocomplete or copy and paste\n        if (eventValue.length > 2) {\n          // see if we can use the string to fill out our values\n          if (validate(eventValue, type)) {\n            // Ensure the value matches the number of inputs\n            const nextValue = eventValue\n              .split(\"\")\n              .filter((_, index) => index < descendants.length)\n\n            setValues(nextValue)\n\n            // if pasting fills the entire input fields, trigger `onComplete`\n            if (nextValue.length === descendants.length) {\n              onComplete?.(nextValue.join(\"\"))\n            }\n          }\n        } else {\n          // only set if the new value is a number\n          if (validate(nextValue, type)) {\n            setValue(nextValue, index)\n          }\n\n          setMoveFocus(true)\n        }\n      }\n\n      const onKeyDown = (event: React.KeyboardEvent) => {\n        if (event.key === \"Backspace\" && manageFocus) {\n          if ((event.target as HTMLInputElement).value === \"\") {\n            const prevInput = descendants[index - 1]\n            if (prevInput) {\n              setValue(\"\", index - 1)\n              prevInput.element?.focus()\n              setMoveFocus(true)\n            }\n          } else {\n            setMoveFocus(false)\n          }\n        }\n      }\n\n      const onFocus = () => {\n        setFocusedIndex(index)\n      }\n\n      const onBlur = () => {\n        setFocusedIndex(-1)\n      }\n\n      const hasFocus = focusedIndex === index\n      const inputType = type === \"number\" ? \"tel\" : \"text\"\n\n      return {\n        \"aria-label\": \"Please enter your pin code\",\n        inputMode: type === \"number\" ? \"numeric\" : \"text\",\n        type: mask ? \"password\" : inputType,\n        ...rest,\n        id: `${id}-${index}`,\n        disabled: isDisabled,\n        \"aria-invalid\": ariaAttr(isInvalid),\n        onChange: callAllHandlers(rest.onChange, onChange),\n        onKeyDown: callAllHandlers(rest.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(rest.onFocus, onFocus),\n        onBlur: callAllHandlers(rest.onBlur, onBlur),\n        value: values[index] || \"\",\n        autoComplete: otp ? \"one-time-code\" : \"off\",\n        placeholder: hasFocus ? \"\" : placeholder,\n      }\n    },\n    [\n      descendants,\n      focusedIndex,\n      getNextValue,\n      id,\n      isDisabled,\n      mask,\n      isInvalid,\n      manageFocus,\n      onComplete,\n      otp,\n      placeholder,\n      setValue,\n      setValues,\n      type,\n      values,\n    ],\n  )\n\n  return {\n    // prop getter\n    getInputProps,\n    // state\n    id,\n    domContext,\n    values,\n    // actions\n    setValue,\n    setValues,\n    clear,\n  }\n}\n\nexport type UsePinInputReturn = ReturnType<typeof usePinInput>\n\nexport interface UsePinInputFieldProps extends InputProps {\n  ref?: React.Ref<HTMLInputElement>\n}\n\nexport function usePinInputField(\n  props: UsePinInputFieldProps = {},\n  forwardedRef: React.Ref<any> = null,\n) {\n  const ref = React.useRef<HTMLInputElement>(null)\n\n  const { domContext, getInputProps } = usePinInputContext()\n\n  const index = useDescendant({\n    context: domContext,\n    element: ref.current,\n  })\n\n  return getInputProps({\n    ...props,\n    ref: mergeRefs(ref, forwardedRef),\n    index,\n  })\n}\n"]},"metadata":{},"sourceType":"module"}