{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useBoolean, useControllableState, useDimensions, useCallbackRef, useEventListener, useIds, useUnmountEffect, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, getBox, getOwnerDocument, isRightClick, mergeRefs, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\n\nexport function useSlider(props) {\n  var _getAriaValueText, _thumbBoxModel$border;\n\n  var {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed,\n    orientation,\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart,\n    onChangeEnd,\n    step = 1,\n    getAriaValueText,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\"]);\n\n  var [isDragging, setDragging] = useBoolean();\n  var [isFocused, setFocused] = useBoolean();\n  var [eventSource, setEventSource] = useState();\n  var isInteractive = !(isDisabled || isReadOnly);\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n\n  var [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange\n  });\n  /**\n   * Slider uses DOM APIs to add and remove event listeners.\n   * Noticed some issues with React's synthetic events.\n   *\n   * We use `ref` to save the functions used to remove\n   * the event listeners.\n   *\n   * Ideally, we'll love to use pointer-events API but it is\n   * not fully supported in all browsers.\n   */\n\n  var cleanUpRef = useRef({});\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n\n  var value = clampValue(computedValue, min, max);\n  var reversedValue = max - value + min;\n  var trackValue = isReversed ? reversedValue : value;\n  var trackPercent = valueToPercent(trackValue, min, max);\n  var isVertical = orientation === \"vertical\";\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var thumbRef = useRef(null);\n  var rootRef = useRef(null);\n  /**\n   * Generate unique ids for component parts\n   */\n\n  var [thumbId, trackId] = useIds(idProp, \"slider-thumb\", \"slider-track\");\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   */\n\n  var getValueFromPointer = useCallback(event => {\n    var _event$touches$, _event$touches;\n\n    if (!trackRef.current) return undefined;\n    var trackRect = getBox(trackRef.current).borderBox;\n    var {\n      clientX,\n      clientY\n    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;\n    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    var length = isVertical ? trackRect.height : trackRect.width;\n    var percent = diff / length;\n\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n\n    var nextValue = percentToValue(percent, min, max);\n\n    if (step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, min, step));\n    }\n\n    nextValue = clampValue(nextValue, min, max);\n    return nextValue;\n  }, [isVertical, isReversed, max, min, step]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var constrain = useCallback(value => {\n    // bail out if slider isn't interactive\n    if (!isInteractive) return;\n    value = parseFloat(roundValueToStep(value, min, oneStep));\n    value = clampValue(value, min, max);\n    setValue(value);\n  }, [oneStep, max, min, setValue, isInteractive]);\n  var actions = useMemo(() => ({\n    stepUp: function stepUp(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var next = isReversed ? value - step : value + step;\n      constrain(next);\n    },\n    stepDown: function stepDown(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var next = isReversed ? value + step : value - step;\n      constrain(next);\n    },\n    reset: () => constrain(defaultValue || 0),\n    stepTo: value => constrain(value)\n  }), [constrain, isReversed, value, oneStep, defaultValue]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => actions.stepUp(),\n      ArrowUp: () => actions.stepUp(),\n      ArrowLeft: () => actions.stepDown(),\n      ArrowDown: () => actions.stepDown(),\n      PageUp: () => actions.stepUp(tenSteps),\n      PageDown: () => actions.stepDown(tenSteps),\n      Home: () => constrain(min),\n      End: () => constrain(max)\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      setEventSource(\"keyboard\");\n      action(event);\n    }\n  }, [actions, constrain, max, min, tenSteps]);\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n\n  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n\n  var thumbBoxModel = useDimensions(thumbRef);\n  var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {\n    width: 0,\n    height: 0\n  };\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var thumbStyle = _extends({\n    position: \"absolute\",\n    userSelect: \"none\",\n    touchAction: \"none\"\n  }, orient({\n    orientation,\n    vertical: {\n      bottom: \"calc(\" + trackPercent + \"% - \" + thumbRect.height / 2 + \"px)\"\n    },\n    horizontal: {\n      left: \"calc(\" + trackPercent + \"% - \" + thumbRect.width / 2 + \"px)\"\n    }\n  }));\n\n  var rootStyle = _extends({\n    position: \"relative\",\n    touchAction: \"none\",\n    WebkitTapHighlightColor: \"rgba(0,0,0,0)\",\n    userSelect: \"none\",\n    outline: 0\n  }, orient({\n    orientation,\n    vertical: {\n      paddingLeft: thumbRect.width / 2,\n      paddingRight: thumbRect.width / 2\n    },\n    horizontal: {\n      paddingTop: thumbRect.height / 2,\n      paddingBottom: thumbRect.height / 2\n    }\n  }));\n\n  var trackStyle = _extends({\n    position: \"absolute\"\n  }, orient({\n    orientation,\n    vertical: {\n      left: \"50%\",\n      transform: \"translateX(-50%)\",\n      height: \"100%\"\n    },\n    horizontal: {\n      top: \"50%\",\n      transform: \"translateY(-50%)\",\n      width: \"100%\"\n    }\n  }));\n\n  var innerTrackStyle = _extends({}, trackStyle, orient({\n    orientation,\n    vertical: isReversed ? {\n      height: 100 - trackPercent + \"%\",\n      top: 0\n    } : {\n      height: trackPercent + \"%\",\n      bottom: 0\n    },\n    horizontal: isReversed ? {\n      width: 100 - trackPercent + \"%\",\n      right: 0\n    } : {\n      width: trackPercent + \"%\",\n      left: 0\n    }\n  }));\n\n  useUpdateEffect(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      focus(thumbRef.current, {\n        nextTick: true\n      });\n    }\n  }, [value]);\n  useUpdateEffect(() => {\n    var shouldUpdate = !isDragging && eventSource !== \"keyboard\";\n\n    if (shouldUpdate) {\n      onChangeEnd == null ? void 0 : onChangeEnd(value);\n    }\n\n    if (eventSource === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(value);\n    }\n  }, [isDragging, onChangeEnd, value, eventSource]);\n  var onMouseDown = useCallbackRef(event => {\n    /**\n     * Prevent update if it is right-click\n     */\n    if (isRightClick(event)) return;\n    if (!isInteractive || !rootRef.current) return;\n    setDragging.on();\n    onChangeStart == null ? void 0 : onChangeStart(value);\n    var doc = getOwnerDocument(rootRef.current);\n\n    var run = event => {\n      var nextValue = getValueFromPointer(event);\n\n      if (nextValue != null) {\n        setEventSource(\"mouse\");\n        setValue(nextValue);\n      }\n    };\n\n    run(event);\n    doc == null ? void 0 : doc.addEventListener(\"mousemove\", run);\n\n    var clean = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"mousemove\", run);\n      setDragging.off();\n    };\n\n    doc == null ? void 0 : doc.addEventListener(\"mouseup\", clean);\n\n    cleanUpRef.current.mouseup = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"mouseup\", clean);\n    };\n  });\n  var onTouchStart = useCallbackRef(event => {\n    if (!isInteractive || !rootRef.current) return; // Prevent scrolling for touch events\n\n    event.preventDefault();\n    setDragging.on();\n    onChangeStart == null ? void 0 : onChangeStart(value);\n    var doc = getOwnerDocument(rootRef.current);\n\n    var run = event => {\n      var nextValue = getValueFromPointer(event);\n\n      if (nextValue != null) {\n        setEventSource(\"touch\");\n        setValue(nextValue);\n      }\n    };\n\n    run(event);\n    doc == null ? void 0 : doc.addEventListener(\"touchmove\", run);\n\n    var clean = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"touchmove\", run);\n      setDragging.off();\n    };\n\n    doc == null ? void 0 : doc.addEventListener(\"touchend\", clean);\n    doc == null ? void 0 : doc.addEventListener(\"touchcancel\", clean);\n\n    cleanUpRef.current.touchend = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"touchend\", clean);\n    };\n\n    cleanUpRef.current.touchcancel = () => {\n      doc == null ? void 0 : doc.removeEventListener(\"touchcancel\", clean);\n    };\n  });\n  /**\n   * Remove all event handlers\n   */\n\n  var detach = () => {\n    Object.values(cleanUpRef.current).forEach(cleanup => {\n      cleanup == null ? void 0 : cleanup();\n    });\n    cleanUpRef.current = {};\n  };\n  /**\n   * Ensure we clean up listeners when slider unmounts\n   */\n\n\n  useUnmountEffect(detach);\n  useUpdateEffect(() => {\n    if (!isDragging) detach();\n  }, [isDragging]);\n  cleanUpRef.current.mousedown = useEventListener(\"mousedown\", onMouseDown, rootRef.current);\n  cleanUpRef.current.touchstart = useEventListener(\"touchstart\", onTouchStart, rootRef.current);\n\n  var getRootProps = function getRootProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, htmlProps, {\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  };\n\n  var getTrackProps = function getTrackProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  };\n\n  var getInnerTrackProps = function getInnerTrackProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  };\n\n  var getThumbProps = function getThumbProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: 0,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: _extends({}, props.style, thumbStyle),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off)\n    });\n  };\n\n  var getMarkerProps = function getMarkerProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var isInRange = !(props.value < min || props.value > max);\n    var isHighlighted = value >= props.value;\n    var markerPercent = valueToPercent(props.value, min, max);\n\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation,\n      vertical: {\n        bottom: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      },\n      horizontal: {\n        left: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      }\n    }));\n\n    return _extends({}, props, {\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  };\n\n  var getInputProps = function getInputProps(props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      type: \"hidden\",\n      value,\n      name\n    });\n  };\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps\n  };\n}\n\nfunction orient(options) {\n  var {\n    orientation,\n    vertical,\n    horizontal\n  } = options;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\n\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}","map":{"version":3,"mappings":"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","names":["useBoolean","useControllableState","useDimensions","useCallbackRef","useEventListener","useIds","useUnmountEffect","useUpdateEffect","ariaAttr","callAllHandlers","clampValue","dataAttr","focus","getBox","getOwnerDocument","isRightClick","mergeRefs","normalizeEventKey","percentToValue","roundValueToStep","valueToPercent","useCallback","useMemo","useRef","useState","useSlider","props","min","max","onChange","value","valueProp","defaultValue","isReversed","orientation","id","idProp","isDisabled","isReadOnly","onChangeStart","onChangeEnd","step","getAriaValueText","ariaValueText","ariaLabel","ariaLabelledBy","name","focusThumbOnChange","htmlProps","isDragging","setDragging","isFocused","setFocused","eventSource","setEventSource","isInteractive","computedValue","setValue","getDefaultValue","cleanUpRef","reversedValue","trackValue","trackPercent","isVertical","trackRef","thumbRef","rootRef","thumbId","trackId","getValueFromPointer","event","current","undefined","trackRect","borderBox","clientX","clientY","touches","_event$touches","diff","bottom","left","length","height","width","percent","nextValue","parseFloat","tenSteps","oneStep","constrain","actions","stepUp","next","stepDown","reset","stepTo","onKeyDown","eventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","preventDefault","stopPropagation","valueText","thumbBoxModel","thumbRect","thumbStyle","position","userSelect","touchAction","orient","vertical","horizontal","rootStyle","WebkitTapHighlightColor","outline","paddingLeft","paddingRight","paddingTop","paddingBottom","trackStyle","transform","top","innerTrackStyle","right","nextTick","shouldUpdate","onMouseDown","on","doc","run","addEventListener","clean","removeEventListener","off","mouseup","onTouchStart","touchend","touchcancel","detach","Object","values","forEach","cleanup","mousedown","touchstart","getRootProps","ref","tabIndex","style","getTrackProps","getInnerTrackProps","getThumbProps","role","onFocus","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","pointerEvents","getInputProps","type","state","options"],"sources":["../../src/use-slider.ts"],"sourcesContent":["import {\n  useBoolean,\n  useControllableState,\n  useDimensions,\n  useCallbackRef,\n  useEventListener,\n  useIds,\n  useUnmountEffect,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  Dict,\n  EventKeyMap,\n  focus,\n  getBox,\n  getOwnerDocument,\n  isRightClick,\n  mergeRefs,\n  normalizeEventKey,\n  percentToValue,\n  PropGetter,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { CSSProperties, useCallback, useMemo, useRef, useState } from \"react\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * function gets called whenever the user starts dragging the slider handle\n   */\n  onChangeStart?(value: number): void\n  /**\n   * function gets called whenever the user stops dragging the slider handle.\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * function gets called whenever the slider handle is being dragged or clicked\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n}\n\ntype EventSource = \"mouse\" | \"touch\" | \"keyboard\"\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed,\n    orientation,\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart,\n    onChangeEnd,\n    step = 1,\n    getAriaValueText,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const [isDragging, setDragging] = useBoolean()\n  const [isFocused, setFocused] = useBoolean()\n  const [eventSource, setEventSource] = useState<EventSource>()\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  /**\n   * Slider uses DOM APIs to add and remove event listeners.\n   * Noticed some issues with React's synthetic events.\n   *\n   * We use `ref` to save the functions used to remove\n   * the event listeners.\n   *\n   * Ideally, we'll love to use pointer-events API but it is\n   * not fully supported in all browsers.\n   */\n  const cleanUpRef = useRef<Dict<Function>>({})\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const trackPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<any>(null)\n  const thumbRef = useRef<any>(null)\n  const rootRef = useRef<any>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`)\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   */\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return undefined\n\n      const trackRect = getBox(trackRef.current).borderBox\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) {\n        nextValue = parseFloat(roundValueToStep(nextValue, min, step))\n      }\n\n      nextValue = clampValue(nextValue, min, max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, max, min, step],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const constrain = useCallback(\n    (value: number) => {\n      // bail out if slider isn't interactive\n      if (!isInteractive) return\n      value = parseFloat(roundValueToStep(value, min, oneStep))\n      value = clampValue(value, min, max)\n      setValue(value)\n    },\n    [oneStep, max, min, setValue, isInteractive],\n  )\n\n  const actions = useMemo(\n    () => ({\n      stepUp: (step = oneStep) => {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown: (step = oneStep) => {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset: () => constrain(defaultValue || 0),\n      stepTo: (value: number) => constrain(value),\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        setEventSource(\"keyboard\")\n        action(event)\n      }\n    },\n    [actions, constrain, max, min, tenSteps],\n  )\n\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n  const thumbBoxModel = useDimensions(thumbRef)\n  const thumbRect = thumbBoxModel?.borderBox ?? {\n    width: 0,\n    height: 0,\n  }\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const thumbStyle: React.CSSProperties = {\n    position: \"absolute\",\n    userSelect: \"none\",\n    touchAction: \"none\",\n    ...orient({\n      orientation,\n      vertical: {\n        bottom: `calc(${trackPercent}% - ${thumbRect.height / 2}px)`,\n      },\n      horizontal: {\n        left: `calc(${trackPercent}% - ${thumbRect.width / 2}px)`,\n      },\n    }),\n  }\n\n  const rootStyle: React.CSSProperties = {\n    position: \"relative\",\n    touchAction: \"none\",\n    WebkitTapHighlightColor: \"rgba(0,0,0,0)\",\n    userSelect: \"none\",\n    outline: 0,\n    ...orient({\n      orientation,\n      vertical: {\n        paddingLeft: thumbRect.width / 2,\n        paddingRight: thumbRect.width / 2,\n      },\n      horizontal: {\n        paddingTop: thumbRect.height / 2,\n        paddingBottom: thumbRect.height / 2,\n      },\n    }),\n  }\n\n  const trackStyle: React.CSSProperties = {\n    position: \"absolute\",\n    ...orient({\n      orientation,\n      vertical: {\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        height: \"100%\",\n      },\n      horizontal: {\n        top: \"50%\",\n        transform: \"translateY(-50%)\",\n        width: \"100%\",\n      },\n    }),\n  }\n\n  const innerTrackStyle: React.CSSProperties = {\n    ...trackStyle,\n    ...orient({\n      orientation,\n      vertical: isReversed\n        ? { height: `${100 - trackPercent}%`, top: 0 }\n        : { height: `${trackPercent}%`, bottom: 0 },\n      horizontal: isReversed\n        ? { width: `${100 - trackPercent}%`, right: 0 }\n        : { width: `${trackPercent}%`, left: 0 },\n    }),\n  }\n\n  useUpdateEffect(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      focus(thumbRef.current, { nextTick: true })\n    }\n  }, [value])\n\n  useUpdateEffect(() => {\n    const shouldUpdate = !isDragging && eventSource !== \"keyboard\"\n\n    if (shouldUpdate) {\n      onChangeEnd?.(value)\n    }\n\n    if (eventSource === \"keyboard\") {\n      onChangeEnd?.(value)\n    }\n  }, [isDragging, onChangeEnd, value, eventSource])\n\n  const onMouseDown = useCallbackRef((event: MouseEvent) => {\n    /**\n     * Prevent update if it is right-click\n     */\n    if (isRightClick(event)) return\n\n    if (!isInteractive || !rootRef.current) return\n\n    setDragging.on()\n    onChangeStart?.(value)\n\n    const doc = getOwnerDocument(rootRef.current)\n\n    const run = (event: MouseEvent) => {\n      const nextValue = getValueFromPointer(event)\n\n      if (nextValue != null) {\n        setEventSource(\"mouse\")\n        setValue(nextValue)\n      }\n    }\n\n    run(event)\n\n    doc?.addEventListener(\"mousemove\", run)\n\n    const clean = () => {\n      doc?.removeEventListener(\"mousemove\", run)\n      setDragging.off()\n    }\n\n    doc?.addEventListener(\"mouseup\", clean)\n    cleanUpRef.current.mouseup = () => {\n      doc?.removeEventListener(\"mouseup\", clean)\n    }\n  })\n\n  const onTouchStart = useCallbackRef((event: TouchEvent) => {\n    if (!isInteractive || !rootRef.current) return\n\n    // Prevent scrolling for touch events\n    event.preventDefault()\n\n    setDragging.on()\n    onChangeStart?.(value)\n\n    const doc = getOwnerDocument(rootRef.current)\n\n    const run = (event: TouchEvent) => {\n      const nextValue = getValueFromPointer(event)\n\n      if (nextValue != null) {\n        setEventSource(\"touch\")\n        setValue(nextValue)\n      }\n    }\n\n    run(event)\n\n    doc?.addEventListener(\"touchmove\", run)\n\n    const clean = () => {\n      doc?.removeEventListener(\"touchmove\", run)\n      setDragging.off()\n    }\n\n    doc?.addEventListener(\"touchend\", clean)\n    doc?.addEventListener(\"touchcancel\", clean)\n\n    cleanUpRef.current.touchend = () => {\n      doc?.removeEventListener(\"touchend\", clean)\n    }\n\n    cleanUpRef.current.touchcancel = () => {\n      doc?.removeEventListener(\"touchcancel\", clean)\n    }\n  })\n\n  /**\n   * Remove all event handlers\n   */\n  const detach = () => {\n    Object.values(cleanUpRef.current).forEach((cleanup) => {\n      cleanup?.()\n    })\n    cleanUpRef.current = {}\n  }\n\n  /**\n   * Ensure we clean up listeners when slider unmounts\n   */\n  useUnmountEffect(detach)\n\n  useUpdateEffect(() => {\n    if (!isDragging) detach()\n  }, [isDragging])\n\n  cleanUpRef.current.mousedown = useEventListener(\n    \"mousedown\",\n    onMouseDown,\n    rootRef.current,\n  )\n\n  cleanUpRef.current.touchstart = useEventListener(\n    \"touchstart\",\n    onTouchStart,\n    rootRef.current,\n  )\n\n  const getRootProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ...htmlProps,\n    ref: mergeRefs(ref, rootRef),\n    tabIndex: -1,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    \"data-focused\": dataAttr(isFocused),\n    style: {\n      ...props.style,\n      ...rootStyle,\n    },\n  })\n\n  const getTrackProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref: mergeRefs(ref, trackRef),\n    id: trackId,\n    \"data-disabled\": dataAttr(isDisabled),\n    style: {\n      ...props.style,\n      ...trackStyle,\n    },\n  })\n\n  const getInnerTrackProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    style: {\n      ...props.style,\n      ...innerTrackStyle,\n    },\n  })\n\n  const getThumbProps: PropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref: mergeRefs(ref, thumbRef),\n    role: \"slider\",\n    tabIndex: 0,\n    id: thumbId,\n    \"data-active\": dataAttr(isDragging),\n    \"aria-valuetext\": valueText,\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-valuenow\": value,\n    \"aria-orientation\": orientation,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    \"aria-readonly\": ariaAttr(isReadOnly),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n    style: {\n      ...props.style,\n      ...thumbStyle,\n    },\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n    onFocus: callAllHandlers(props.onFocus, setFocused.on),\n    onBlur: callAllHandlers(props.onBlur, setFocused.off),\n  })\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = (\n    props = {},\n    ref = null,\n  ) => {\n    const isInRange = !(props.value < min || props.value > max)\n    const isHighlighted = value >= props.value\n    const markerPercent = valueToPercent(props.value, min, max)\n\n    const markerStyle: React.CSSProperties = {\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      ...orient({\n        orientation,\n        vertical: {\n          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n        },\n        horizontal: {\n          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n        },\n      }),\n    }\n\n    return {\n      ...props,\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: {\n        ...props.style,\n        ...markerStyle,\n      },\n    }\n  }\n\n  const getInputProps: PropGetter<HTMLInputElement> = (\n    props = {},\n    ref = null,\n  ) => ({\n    ...props,\n    ref,\n    type: \"hidden\",\n    value,\n    name,\n  })\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: CSSProperties\n  horizontal: CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"]},"metadata":{},"sourceType":"module"}